<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Object Analyzer v7.0 - Proper Contour Drawing</title>
    <meta name="version" content="7.0.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, sans-serif;
            background-color: #f3f4f6;
        }
        
        .canvas-container {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        
        .canvas-container:hover {
            transform: scale(1.02);
            transition: transform 0.2s;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5rem;
        }
    </style>
</head>
<body>
    <div class="max-w-7xl mx-auto p-6">
        <!-- Header -->
        <div class="bg-gradient-to-r from-blue-600 to-purple-700 text-white p-6 rounded-xl shadow-xl mb-6">
            <h1 class="text-4xl font-bold mb-2">Sound Object Analyzer v7.0</h1>
            <p class="text-blue-100 text-lg">Proper Contour Visualization - No Radial Spikes!</p>
            <div class="mt-4 flex flex-wrap gap-2">
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Clean Contour Drawing</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Original Shape Preservation</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Proper Averaging</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Publication Ready</span>
            </div>
        </div>
        
        <!-- Instructions -->
        <div class="bg-blue-50 p-6 rounded-xl mb-6 border-2 border-blue-200">
            <h2 class="text-xl font-bold text-blue-900 mb-3">How to Use</h2>
            <ol class="list-decimal list-inside space-y-2 text-gray-700">
                <li><strong>Upload Images:</strong> Select PNG files or ZIP archives</li>
                <li><strong>Process:</strong> Click "Analyze & Generate Visualizations"</li>
                <li><strong>View Results:</strong> Clean composites with proper contours (not radial spikes)</li>
                <li><strong>Download:</strong> Click any image to save</li>
            </ol>
        </div>
        
        <!-- File Upload -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Upload Participant Images</h2>
            <input 
                type="file" 
                id="image-upload" 
                accept="image/png,.zip,application/zip" 
                multiple
                class="block w-full text-sm text-gray-700 mb-4
                    file:mr-4 file:py-3 file:px-6
                    file:rounded-xl file:border-0
                    file:text-sm file:font-bold
                    file:bg-gradient-to-r file:from-blue-500 file:to-blue-600
                    file:text-white
                    hover:file:from-blue-600 hover:file:to-blue-700
                    cursor-pointer"
            />
            
            <div id="file-status" class="text-sm text-gray-600 mb-4"></div>
            
            <button 
                id="analyze-btn" 
                class="bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 px-6 rounded-xl hover:from-green-600 hover:to-emerald-700 transition-all shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                disabled>
                ðŸ”¬ Analyze & Generate Visualizations
            </button>
        </div>
        
        <!-- Progress -->
        <div id="progress-container" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6">
            <div class="flex justify-between text-sm text-gray-600 mb-2">
                <span id="progress-text">Processing...</span>
                <span id="progress-percentage">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-3 overflow-hidden">
                <div id="progress-bar" class="bg-gradient-to-r from-blue-500 to-green-500 h-full rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Results -->
        <div id="visualization-container" class="hidden">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">Composite Visualizations</h2>
            <div id="viz-grid" class="analysis-grid"></div>
        </div>
    </div>
    
    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        
        const CANVAS_SIZE = 1000;
        const GRID_RANGE = 10; // -10 to +10 units
        const CENTER_X = 500;
        const CENTER_Y = 500;
        const SCALE = 50; // pixels per unit
        
        // Conversion functions matching original drawing tool
        const pixelsToUnits = (pixels) => pixels / SCALE;
        const unitsToPixels = (units) => units * SCALE;
        
        const canvasToUnit = (canvasX, canvasY) => ({
            x: (canvasX - CENTER_X) / SCALE,
            y: (CENTER_Y - canvasY) / SCALE  // Inverted Y for proper orientation
        });
        
        const unitToCanvas = (unitX, unitY) => ({
            x: CENTER_X + unitX * SCALE,
            y: CENTER_Y - unitY * SCALE  // Inverted Y
        });
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        document.addEventListener('DOMContentLoaded', () => {
            const uploadInput = document.getElementById('image-upload');
            const analyzeBtn = document.getElementById('analyze-btn');
            
            uploadInput.addEventListener('change', handleFileUpload);
            analyzeBtn.addEventListener('click', startAnalysis);
        });
        
        function handleFileUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            const statusDiv = document.getElementById('file-status');
            const analyzeBtn = document.getElementById('analyze-btn');
            
            const zipCount = files.filter(f => f.name.toLowerCase().endsWith('.zip')).length;
            const pngCount = files.filter(f => f.name.toLowerCase().endsWith('.png')).length;
            
            statusDiv.innerHTML = `âœ… ${files.length} file(s) uploaded (${zipCount} ZIP, ${pngCount} PNG)`;
            
            analyzeBtn.disabled = false;
            analyzeBtn.classList.remove('disabled:opacity-50', 'disabled:cursor-not-allowed');
        }
        
        async function startAnalysis() {
            const uploadInput = document.getElementById('image-upload');
            const files = Array.from(uploadInput.files);
            
            if (files.length === 0) {
                alert('Please upload files first');
                return;
            }
            
            try {
                await analyzeData(files);
            } catch (error) {
                console.error('Analysis error:', error);
                alert(`Analysis failed: ${error.message}`);
            }
        }
        
        // ============================================
        // CRITICAL: EXTRACT ACTUAL CONTOURS FROM IMAGES
        // ============================================
        
        async function extractShapesFromImage(imageData, filename) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            
            // Find all colored pixels
            const redPixels = [];
            const bluePixels = [];
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];
                    
                    // Skip transparent or white pixels
                    if (a < 128 || (r > 240 && g > 240 && b > 240)) continue;
                    
                    // Skip gray pixels (grid lines)
                    if (Math.abs(r - g) < 20 && Math.abs(g - b) < 20 && r > 140 && r < 200) continue;
                    
                    // Separate by color - blue overlaps red
                    if (b > r && b > g) {
                        bluePixels.push({ x, y });
                    } else if (r > b && r > g) {
                        redPixels.push({ x, y });
                    }
                }
            }
            
            const shapes = [];
            
            // Process red shape - extract EDGE pixels only
            if (redPixels.length > 0) {
                const redEdge = extractEdgePixels(redPixels, width, height, data);
                const redContour = orderContourPoints(redEdge);
                const redCentroid = calculateCentroid(redContour);
                
                shapes.push({
                    phase: 'red',
                    contour: redContour, // These are canvas pixel coordinates
                    centroid: redCentroid,
                    area: calculateContourArea(redContour)
                });
            }
            
            // Process blue shape - extract EDGE pixels only
            if (bluePixels.length > 0) {
                const blueEdge = extractEdgePixels(bluePixels, width, height, data);
                const blueContour = orderContourPoints(blueEdge);
                const blueCentroid = calculateCentroid(blueContour);
                
                shapes.push({
                    phase: 'blue',
                    contour: blueContour, // These are canvas pixel coordinates
                    centroid: blueCentroid,
                    area: calculateContourArea(blueContour)
                });
            }
            
            return shapes;
        }
        
        function extractEdgePixels(pixels, width, height, imageData) {
            const pixelSet = new Set(pixels.map(p => `${p.x},${p.y}`));
            const edgePixels = [];
            
            pixels.forEach(pixel => {
                // Check if this pixel is on the edge (has at least one non-colored neighbor)
                let isEdge = false;
                
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = pixel.x + dx;
                        const ny = pixel.y + dy;
                        
                        // Check bounds
                        if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
                            isEdge = true;
                            break;
                        }
                        
                        // Check if neighbor is not in our pixel set
                        if (!pixelSet.has(`${nx},${ny}`)) {
                            isEdge = true;
                            break;
                        }
                    }
                    if (isEdge) break;
                }
                
                if (isEdge) {
                    edgePixels.push(pixel);
                }
            });
            
            return edgePixels;
        }
        
        function orderContourPoints(edgePixels) {
            if (edgePixels.length === 0) return [];
            
            // Start with an arbitrary point
            const ordered = [edgePixels[0]];
            const remaining = new Set(edgePixels.slice(1));
            
            while (remaining.size > 0 && ordered.length < edgePixels.length) {
                const last = ordered[ordered.length - 1];
                let nearest = null;
                let minDist = Infinity;
                
                // Find nearest unvisited point
                remaining.forEach(point => {
                    const dist = Math.sqrt(
                        Math.pow(point.x - last.x, 2) + 
                        Math.pow(point.y - last.y, 2)
                    );
                    
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = point;
                    }
                });
                
                if (nearest && minDist < 50) { // Only connect if reasonably close
                    ordered.push(nearest);
                    remaining.delete(nearest);
                } else {
                    break; // Gap too large, stop
                }
            }
            
            return ordered;
        }
        
        function calculateCentroid(contour) {
            if (contour.length === 0) return { x: CENTER_X, y: CENTER_Y };
            
            const sumX = contour.reduce((sum, p) => sum + p.x, 0);
            const sumY = contour.reduce((sum, p) => sum + p.y, 0);
            
            return {
                x: sumX / contour.length,
                y: sumY / contour.length
            };
        }
        
        function calculateContourArea(contour) {
            if (contour.length < 3) return 0;
            
            // Shoelace formula
            let area = 0;
            for (let i = 0; i < contour.length; i++) {
                const j = (i + 1) % contour.length;
                area += contour[i].x * contour[j].y;
                area -= contour[j].x * contour[i].y;
            }
            
            return Math.abs(area / 2) / (SCALE * SCALE); // Convert to square units
        }
        
        // ============================================
        // AVERAGING - Creates smooth average contour
        // ============================================
        
        function calculateAverageShape(shapes) {
            if (shapes.length === 0) return null;
            
            // Calculate average centroid
            const avgCentroid = {
                x: shapes.reduce((sum, s) => sum + s.centroid.x, 0) / shapes.length,
                y: shapes.reduce((sum, s) => sum + s.centroid.y, 0) / shapes.length
            };
            
            // Convert all contours to polar coordinates relative to average centroid
            const polarContours = shapes.map(shape => {
                return shape.contour.map(point => {
                    const dx = point.x - avgCentroid.x;
                    const dy = point.y - avgCentroid.y;
                    const angle = Math.atan2(dy, dx);
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    return { angle, radius };
                });
            });
            
            // Create averaged contour by binning angles
            const numBins = 360;
            const bins = new Array(numBins).fill(null).map(() => []);
            
            polarContours.forEach(contour => {
                contour.forEach(point => {
                    let binIndex = Math.floor(((point.angle + Math.PI) / (2 * Math.PI)) * numBins);
                    binIndex = (binIndex + numBins) % numBins;
                    bins[binIndex].push(point.radius);
                });
            });
            
            // Create smooth averaged contour
            const avgContour = [];
            for (let i = 0; i < numBins; i++) {
                if (bins[i].length > 0) {
                    const avgRadius = bins[i].reduce((sum, r) => sum + r, 0) / bins[i].length;
                    const angle = (i / numBins) * 2 * Math.PI - Math.PI;
                    
                    avgContour.push({
                        x: avgCentroid.x + avgRadius * Math.cos(angle),
                        y: avgCentroid.y + avgRadius * Math.sin(angle)
                    });
                }
            }
            
            // Fill gaps with interpolation
            const finalContour = [];
            for (let i = 0; i < avgContour.length; i++) {
                finalContour.push(avgContour[i]);
                
                // Check for gap to next point
                const next = avgContour[(i + 1) % avgContour.length];
                const dist = Math.sqrt(
                    Math.pow(next.x - avgContour[i].x, 2) + 
                    Math.pow(next.y - avgContour[i].y, 2)
                );
                
                if (dist > 10) { // If gap, interpolate
                    const steps = Math.ceil(dist / 5);
                    for (let j = 1; j < steps; j++) {
                        const t = j / steps;
                        finalContour.push({
                            x: avgContour[i].x + (next.x - avgContour[i].x) * t,
                            y: avgContour[i].y + (next.y - avgContour[i].y) * t
                        });
                    }
                }
            }
            
            // Calculate mean radius
            const radii = finalContour.map(p => {
                const dx = p.x - avgCentroid.x;
                const dy = p.y - avgCentroid.y;
                return Math.sqrt(dx * dx + dy * dy) / SCALE; // Convert to units
            });
            
            const meanRadius = radii.reduce((sum, r) => sum + r, 0) / radii.length;
            
            return {
                contour: finalContour,
                centroid: avgCentroid,
                meanRadius: meanRadius,
                n: shapes.length
            };
        }
        
        // ============================================
        // DRAWING FUNCTIONS - The Key Fix!
        // ============================================
        
        function drawCompositeVisualization(canvas, frequency, redShapes, blueShapes, redAvg, blueAvg) {
            const ctx = canvas.getContext('2d');
            
            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawGrid(ctx);
            
            // CRITICAL: Draw individual shapes as CLOSED CONTOURS, not radial lines
            
            // Draw red individual shapes in gray
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            
            redShapes.forEach(shape => {
                if (shape.contour && shape.contour.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(shape.contour[0].x, shape.contour[0].y);
                    
                    for (let i = 1; i < shape.contour.length; i++) {
                        ctx.lineTo(shape.contour[i].x, shape.contour[i].y);
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            
            // Draw blue individual shapes in gray
            blueShapes.forEach(shape => {
                if (shape.contour && shape.contour.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(shape.contour[0].x, shape.contour[0].y);
                    
                    for (let i = 1; i < shape.contour.length; i++) {
                        ctx.lineTo(shape.contour[i].x, shape.contour[i].y);
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            
            ctx.globalAlpha = 1.0;
            
            // Draw averaged red shape
            if (redAvg && redAvg.contour && redAvg.contour.length > 0) {
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                ctx.beginPath();
                ctx.moveTo(redAvg.contour[0].x, redAvg.contour[0].y);
                
                for (let i = 1; i < redAvg.contour.length; i++) {
                    ctx.lineTo(redAvg.contour[i].x, redAvg.contour[i].y);
                }
                
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw averaged blue shape (dashed)
            if (blueAvg && blueAvg.contour && blueAvg.contour.length > 0) {
                ctx.strokeStyle = '#0000FF';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                
                ctx.beginPath();
                ctx.moveTo(blueAvg.contour[0].x, blueAvg.contour[0].y);
                
                for (let i = 1; i < blueAvg.contour.length; i++) {
                    ctx.lineTo(blueAvg.contour[i].x, blueAvg.contour[i].y);
                }
                
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Add frequency label
            ctx.fillStyle = 'black';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(frequency, canvas.width / 2, 40);
            
            // Add statistics
            const nTotal = redShapes.length + blueShapes.length;
            const meanRadius = redAvg ? redAvg.meanRadius.toFixed(2) : 
                              (blueAvg ? blueAvg.meanRadius.toFixed(2) : '0.00');
            
            ctx.font = '16px Arial';
            ctx.fillText(`N=${nTotal}, mean r=${meanRadius} (centroid avg)`, canvas.width / 2, canvas.height - 20);
        }
        
        function drawGrid(ctx) {
            const size = CANVAS_SIZE;
            const gridSize = size / (2 * GRID_RANGE);
            
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // Grid lines
            for (let i = 0; i <= 2 * GRID_RANGE; i++) {
                const pos = i * gridSize;
                
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, size);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(size, pos);
                ctx.stroke();
            }
            
            // Center axes
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(size / 2, 0);
            ctx.lineTo(size / 2, size);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, size / 2);
            ctx.lineTo(size, size / 2);
            ctx.stroke();
        }
        
        // ============================================
        // FILE PROCESSING
        // ============================================
        
        async function loadImagesFromZip(file) {
            const zip = await JSZip.loadAsync(file);
            const images = [];
            
            for (const [path, zipEntry] of Object.entries(zip.files)) {
                if (zipEntry.dir) continue;
                
                if (path.toLowerCase().endsWith('.png')) {
                    const blob = await zipEntry.async('blob');
                    images.push({
                        name: path.split('/').pop(),
                        blob: blob
                    });
                } else if (path.toLowerCase().endsWith('.zip')) {
                    // Handle nested ZIPs
                    const nestedBlob = await zipEntry.async('blob');
                    const nestedFile = new File([nestedBlob], path.split('/').pop());
                    const nestedImages = await loadImagesFromZip(nestedFile);
                    images.push(...nestedImages);
                }
            }
            
            return images;
        }
        
        async function processImage(imageFile) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    img.onload = async () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = CANVAS_SIZE;
                        canvas.height = CANVAS_SIZE;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.drawImage(img, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        const imageData = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        
                        const shapes = await extractShapesFromImage(imageData, imageFile.name);
                        
                        // Parse filename for metadata
                        const parsed = parseFilename(imageFile.name);
                        if (!parsed) {
                            reject(new Error(`Invalid filename: ${imageFile.name}`));
                            return;
                        }
                        
                        resolve(shapes.map(shape => ({
                            ...shape,
                            ...parsed,
                            filename: imageFile.name
                        })));
                    };
                    
                    img.onerror = () => reject(new Error(`Failed to load: ${imageFile.name}`));
                    img.src = e.target.result;
                };
                
                reader.onerror = () => reject(new Error(`Failed to read: ${imageFile.name}`));
                reader.readAsDataURL(imageFile.blob);
            });
        }
        
        function parseFilename(filename) {
            const parts = filename.replace('.png', '').split('_');
            if (parts.length < 2) return null;
            
            // Find frequency
            let frequency = null;
            for (const part of parts) {
                const match = part.match(/(\d+(?:\.\d+)?)hz/i);
                if (match) {
                    frequency = parseFloat(match[1]) + 'Hz';
                    break;
                }
            }
            
            if (!frequency) return null;
            
            const participant = parts[0];
            return { participant, frequency };
        }
        
        function updateProgress(percentage, message) {
            document.getElementById('progress-container').classList.remove('hidden');
            document.getElementById('progress-bar').style.width = `${percentage}%`;
            document.getElementById('progress-text').textContent = message;
            document.getElementById('progress-percentage').textContent = `${Math.round(percentage)}%`;
        }
        
        // ============================================
        // MAIN ANALYSIS FUNCTION
        // ============================================
        
        async function analyzeData(inputFiles) {
            try {
                updateProgress(0, 'Starting analysis...');
                
                // Extract all images
                let allImages = [];
                
                for (const file of inputFiles) {
                    if (file.name.toLowerCase().endsWith('.zip')) {
                        const images = await loadImagesFromZip(file);
                        allImages.push(...images);
                    } else if (file.name.toLowerCase().endsWith('.png')) {
                        allImages.push({ name: file.name, blob: file });
                    }
                }
                
                updateProgress(10, `Found ${allImages.length} images`);
                
                // Process all images
                const processedData = [];
                
                for (let i = 0; i < allImages.length; i++) {
                    try {
                        const result = await processImage(allImages[i]);
                        processedData.push(...result);
                    } catch (error) {
                        console.warn(`Skipping ${allImages[i].name}:`, error);
                    }
                    
                    const progress = 10 + ((i + 1) / allImages.length * 60);
                    updateProgress(progress, `Processing image ${i + 1}/${allImages.length}`);
                }
                
                // Organize by frequency
                const organizedData = {};
                const frequencies = ['31Hz', '62.5Hz', '125Hz', '250Hz', '500Hz', 
                                   '1000Hz', '2000Hz', '4000Hz', '8000Hz', '12000Hz', '16000Hz'];
                
                frequencies.forEach(freq => {
                    organizedData[freq] = { red: [], blue: [] };
                });
                
                processedData.forEach(data => {
                    if (organizedData[data.frequency]) {
                        organizedData[data.frequency][data.phase].push(data);
                    }
                });
                
                updateProgress(75, 'Creating visualizations...');
                
                // Generate visualizations
                const vizGrid = document.getElementById('viz-grid');
                vizGrid.innerHTML = '';
                
                frequencies.forEach(freq => {
                    const redShapes = organizedData[freq].red;
                    const blueShapes = organizedData[freq].blue;
                    
                    if (redShapes.length === 0 && blueShapes.length === 0) return;
                    
                    // Calculate averages
                    const redAvg = redShapes.length > 0 ? calculateAverageShape(redShapes) : null;
                    const blueAvg = blueShapes.length > 0 ? calculateAverageShape(blueShapes) : null;
                    
                    // Create canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = CANVAS_SIZE;
                    canvas.height = CANVAS_SIZE;
                    
                    drawCompositeVisualization(canvas, freq, redShapes, blueShapes, redAvg, blueAvg);
                    
                    // Create container
                    const container = document.createElement('div');
                    container.className = 'canvas-container p-4';
                    container.style.cursor = 'pointer';
                    
                    canvas.style.width = '100%';
                    canvas.style.height = 'auto';
                    
                    container.appendChild(canvas);
                    
                    // Add click to download
                    container.addEventListener('click', () => {
                        const link = document.createElement('a');
                        link.download = `composite_${freq}.png`;
                        link.href = canvas.toDataURL();
                        link.click();
                    });
                    
                    vizGrid.appendChild(container);
                });
                
                updateProgress(100, 'Analysis complete!');
                
                // Show results
                document.getElementById('visualization-container').classList.remove('hidden');
                
                setTimeout(() => {
                    document.getElementById('progress-container').classList.add('hidden');
                }, 2000);
                
            } catch (error) {
                console.error('Analysis error:', error);
                alert(`Error: ${error.message}`);
            }
        }
    </script>
</body>
</html>

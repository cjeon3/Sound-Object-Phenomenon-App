<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sound Object Visualization Research Tool</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sound Viz">
    <meta name="theme-color" content="#1e40af">
    <meta name="description" content="Draw and analyze perceived sound shapes for acoustic research">
    
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            min-height: 100vh;
            overscroll-behavior: none;
            overflow-x: hidden;
            font-family: ui-sans-serif, system-ui, sans-serif;
            background-color: #f3f4f6;
        }
        
        #canvas-container {
            max-width: 100%;
            width: 100%;
            margin: 0 auto;
            position: relative;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border-radius: 0.75rem;
            overflow: hidden;
            background-color: #ffffff;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            aspect-ratio: 1 / 1;
        }
        
        #drawing-canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: crosshair;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }
        
        @media (max-width: 768px) {
            #canvas-container {
                max-width: 100vw;
                margin: 0 -1rem;
                border-radius: 0;
            }
            .frequency-tab {
                font-size: 0.75rem;
                padding: 0.5rem 0.75rem;
            }
            h1 { font-size: 1.75rem !important; }
            h2 { font-size: 1.25rem !important; }
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: linear-gradient(to right, #3b82f6, #8b5cf6);
            height: 0.75rem;
            border-radius: 9999px;
        }
        
        input[type="range"]::-moz-range-track {
            background: linear-gradient(to right, #3b82f6, #8b5cf6);
            height: 0.75rem;
            border-radius: 9999px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 1.75rem;
            width: 1.75rem;
            background: white;
            border: 3px solid #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }
        
        input[type="range"]::-moz-range-thumb {
            height: 1.75rem;
            width: 1.75rem;
            background: white;
            border: 3px solid #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }
        
        .frequency-tab {
            transition: all 0.2s;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .frequency-tab.active {
            background: linear-gradient(to right, #3b82f6, #8b5cf6) !important;
            color: white !important;
            transform: scale(1.05);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
        }
        
        .color-button.selected {
            border: 4px solid white !important;
            box-shadow: 0 0 0 4px #3b82f6 !important;
            transform: scale(1.15) !important;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8">
    
    <div class="max-w-6xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-extrabold text-blue-800 mb-2">Sound Object Phenomenon</h1>
            <p class="text-xl font-semibold text-gray-600">UCI Hearing & Speech Lab</p>
        </header>
        
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6 border border-gray-100">
            <label for="participant-name" class="block text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                </svg>
                Participant Name / ID
            </label>
            <input type="text" id="participant-name" placeholder="P-001" 
                class="w-full px-4 py-3 text-lg border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-2 focus:ring-blue-200 outline-none transition-all">
            <p class="mt-2 text-sm text-gray-500">This ID will be used in the exported data file.</p>
        </div>
        
        <div id="canvas-container" class="bg-white rounded-xl shadow-2xl p-0.5 mb-6">
            <canvas id="drawing-canvas"></canvas>
        </div>
        
        <div class="bg-white p-4 rounded-xl shadow-lg mb-6 border border-gray-100">
            <h2 class="text-lg font-bold text-gray-800 mb-4 flex items-center gap-2">
                <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"></path>
                </svg>
                Select Frequency
            </h2>
            <div id="frequency-tabs" class="flex flex-wrap gap-2"></div>
        </div>
        
        <div class="bg-white p-4 rounded-xl shadow-lg mb-6 flex flex-col space-y-4 border border-gray-100">
            <div class="flex flex-col sm:flex-row flex-wrap items-center gap-3 w-full">
                <div class="w-full">
                    <p class="text-base font-bold text-gray-800 mb-3">Upload an Image</p>
                    <input type="file" id="image-upload" accept="image/*" class="text-sm text-gray-700
                        file:mr-4 file:py-2.5 file:px-5
                        file:rounded-xl file:border-0
                        file:text-sm file:font-bold
                        file:bg-gradient-to-r file:from-blue-500 file:to-blue-600
                        file:text-white
                        hover:file:from-blue-600 hover:file:to-blue-700
                        file:shadow-lg file:transition-all
                        cursor:pointer w-full sm:w-auto
                    "/>
                </div>
            </div>
            
            <div class="flex flex-col sm:flex-row flex-wrap items-center gap-3 w-full pt-4 border-t border-gray-100">
                
                <button id="toggle-drawing" class="w-full sm:w-auto px-6 py-2.5 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-green-500 to-green-600 text-white hover:from-green-600 hover:to-green-700 shadow-lg hover:shadow-xl">
                    Stop Drawing
                </button>
                
                <button id="clear-canvas" class="w-full sm:w-auto px-6 py-2.5 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-red-500 to-red-600 text-white hover:from-red-600 hover:to-red-700 shadow-lg hover:shadow-xl">
                    Clear Current
                </button>
                
                <button id="undo-button" disabled class="w-full sm:w-auto px-6 py-2.5 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-yellow-400 to-yellow-500 text-gray-900 hover:from-yellow-500 hover:to-yellow-600 shadow-lg disabled:opacity-50 disabled:cursor-not-allowed">
                    Undo
                </button>
                
                <button id="redo-button" disabled class="w-full sm:w-auto px-6 py-2.5 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-yellow-400 to-yellow-500 text-gray-900 hover:from-yellow-500 hover:to-yellow-600 shadow-lg disabled:opacity-50 disabled:cursor-not-allowed">
                    Redo
                </button>
                
                <button id="reset-all" class="w-full sm:w-auto px-6 py-2.5 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-gray-600 to-gray-700 text-white hover:from-gray-700 hover:to-gray-800 shadow-lg hover:shadow-xl">
                    üîÑ Reset All
                </button>
            </div>
            
            <div class="pt-4 border-t border-gray-100">
                <p class="text-base font-bold text-gray-800 mb-4 flex items-center gap-2">
                    <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path>
                    </svg>
                    Select Drawing Color
                </p>
                <div id="color-palette" class="flex flex-wrap gap-4"></div>
            </div>
            
            <div class="grid grid-cols-1 gap-6 pt-6 border-t-2 border-gray-200">
                <div class="bg-gradient-to-r from-blue-50 to-purple-50 p-6 rounded-xl shadow-inner">
                    <label for="brush-size-slider" class="block text-base font-bold text-gray-800 mb-4 flex items-center justify-between">
                        <span class="flex items-center gap-2">
                            <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path>
                            </svg>
                            Brush Size
                        </span>
                        <span id="brush-size-value" class="text-2xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600">5</span>
                    </label>
                    <div class="relative">
                        <input id="brush-size-slider" type="range" min="1" max="10" value="5">
                        <div class="flex justify-between mt-2 text-xs font-semibold text-gray-500 px-1">
                            <span>1px (Fine)</span>
                            <span>10px (Thick)</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="status-message" class="text-sm font-medium text-gray-500 w-full text-center md:text-left pt-2 border-t border-gray-100">
                Status: Ready
            </div>
        </div>
        
        <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-100 mb-6">
            <h2 class="text-2xl font-bold text-blue-700 mb-4">Sound Object Area and X,Y Coordinates</h2>
            <div id="results-table-container">
                <p class="text-gray-500 italic">Draw shapes for each frequency to see results.</p>
            </div>
            <div class="mt-4 space-y-2">
                <p class="text-xs text-gray-500 italic">
                    <strong>Unit Measurement:</strong> The coordinate system uses a 20√ó20 grid centered at origin (0,0), spanning from -10 to +10 units on both axes. Each grid square represents one unit of area measurement.
                </p>
                <p class="text-xs text-gray-500 italic">
                    <strong>Area Calculation:</strong> Area is measured in grid squares, where each small box on the grid = 1 area unit. The total grid contains 400 squares (20√ó20).
                </p>
            </div>
        </div>
        
        <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-100 mb-6">
            <h3 class="text-xl font-bold text-gray-800 mb-3 flex items-center gap-2">
                <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                </svg>
                Export Data
            </h3>
            <p class="text-sm text-gray-600 mb-4">
                Download your drawings and data for offline storage or analysis.
            </p>
            <div class="flex flex-col sm:flex-row gap-3">
                <button id="download-all-zip" class="flex-1 px-6 py-3 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-purple-500 to-purple-600 text-white hover:from-purple-600 hover:to-purple-700 shadow-lg hover:shadow-xl">
                    ‚¨áÔ∏è Download All Drawings (ZIP)
                </button>
                
                <button id="export-csv" class="flex-1 px-6 py-3 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-teal-500 to-teal-600 text-white hover:from-teal-600 hover:to-teal-700 shadow-lg hover:shadow-xl">
                    üìÑ Export CSV
                </button>
            </div>
        </div>
        
        <div class="bg-gradient-to-r from-blue-50 to-cyan-50 p-6 rounded-xl shadow-lg border-2 border-blue-200 mb-6">
            <h3 class="text-xl font-bold text-blue-800 mb-3 flex items-center gap-2">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"></path>
                </svg>
                Export Drawings to Google Drive
            </h3>
            <p class="text-sm text-gray-700 mb-4">
                Enter your Google Apps Script Web App URL below to automatically upload all drawings as a ZIP file to your Google Drive.
            </p>
            
            <div class="flex flex-col sm:flex-row gap-3">
                <input 
                    type="url" 
                    id="drive-url-input" 
                    placeholder="https://script.google.com/macros/s/..." 
                    class="flex-1 px-4 py-3 text-sm border-2 border-blue-300 rounded-xl focus:border-blue-500 focus:ring-2 focus:ring-blue-200 outline-none transition-all"
                    value="">
                
                <button id="export-drive-btn" class="px-8 py-3 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700 shadow-lg hover:shadow-xl active:scale-95 whitespace-nowrap">
                    üì§ Export to Drive
                </button>
            </div>
            
            <p class="mt-3 text-xs text-gray-600 italic">
                üí° Tip: Your URL is automatically saved for future exports. 
                <a href="#" id="clear-drive-url" class="text-blue-700 hover:text-blue-900 underline font-semibold">Clear saved URL</a>
            </p>
        </div>
        
        <div class="bg-gradient-to-r from-emerald-50 to-teal-50 p-6 rounded-xl shadow-lg border-2 border-emerald-200">
            <h3 class="text-xl font-bold text-emerald-800 mb-3 flex items-center gap-2">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                Export to Google Sheets
            </h3>
            <p class="text-sm text-gray-700 mb-4">
                Enter your Google Apps Script Web App URL below to automatically send all data to your Google Sheet.
            </p>
            
            <div class="flex flex-col sm:flex-row gap-3">
                <input 
                    type="url" 
                    id="sheets-url-input" 
                    placeholder="https://script.google.com/macros/s/..." 
                    class="flex-1 px-4 py-3 text-sm border-2 border-emerald-300 rounded-xl focus:border-emerald-500 focus:ring-2 focus:ring-emerald-200 outline-none transition-all"
                    value="">
                
                <button id="export-sheets-btn" class="px-8 py-3 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-emerald-500 to-emerald-600 text-white hover:from-emerald-600 hover:to-emerald-700 shadow-lg hover:shadow-xl active:scale-95 whitespace-nowrap">
                    üìä Export to Sheets
                </button>
            </div>
            
            <p class="mt-3 text-xs text-gray-600 italic">
                üí° Tip: Your URL is automatically saved for future exports. 
                <a href="#" id="clear-sheets-url" class="text-emerald-700 hover:text-emerald-900 underline font-semibold">Clear saved URL</a>
            </p>
        </div>
    </div>

    <script>
        // Constants
        const CANVAS_SIZE = 1000;
        const UNIT_RANGE = 10;
        const SCALE_FACTOR = CANVAS_SIZE / (UNIT_RANGE * 2);
        // Circle Radius set to 3 units as requested
        const BACKGROUND_CIRCLE_RADIUS_UNITS = 3; 

        const frequencies = [
            { hz: 31, db: 100 }, { hz: 62.5, db: 100 }, { hz: 125, db: 90 },
            { hz: 250, db: 85 }, { hz: 500, db: 80 }, { hz: 1000, db: 80 },
            { hz: 2000, db: 80 }, { hz: 4000, db: 80 }, { hz: 8000, db: 90 },
            { hz: 12000, db: 85 }, { hz: 16000, db: 85 }
        ];
        
        const colors = [
            { name: 'Red', hex: '#ef4444' }, { name: 'Orange', hex: '#f97316' },
            { name: 'Yellow', hex: '#facc15' }, { name: 'Green', hex: '#10b981' },
            { name: 'Blue', hex: '#3b82f6' }, { name: 'Purple', hex: '#8b5cf6' },
            { name: 'Black', hex: '#000000' }
        ];

        // Global state variables
        let canvas, ctx;
        let selectedColor = colors[0];
        let brushSize = 5;
        let isDrawing = true;
        let isPainting = false;
        let currentPath = [];
        let allFrequencyData = {};
        let currentFrequency = frequencies[0];
        let undoStacks = {};
        let redoStacks = {};
        let backgroundImage = null;

        // Initialize data structures for each frequency
        frequencies.forEach(freq => {
            const key = getFrequencyKey(freq);
            allFrequencyData[key] = [];
            undoStacks[key] = [];
            redoStacks[key] = [];
        });

        // Utility functions
        function getFrequencyKey(freq) {
            return `${freq.hz}Hz_${freq.db}dB`;
        }

        function getCurrentShapes() {
            return allFrequencyData[getFrequencyKey(currentFrequency)] || [];
        }

        function canvasToUnit(x, y) {
            const centerX = CANVAS_SIZE / 2;
            const centerY = CANVAS_SIZE / 2;
            return {
                x: (x - centerX) / SCALE_FACTOR,
                y: (centerY - y) / SCALE_FACTOR
            };
        }

        function unitToCanvas(x, y) {
            const centerX = CANVAS_SIZE / 2;
            const centerY = CANVAS_SIZE / 2;
            return {
                x: x * SCALE_FACTOR + centerX,
                y: centerY - y * SCALE_FACTOR
            };
        }

        function hexToColorName(hex) {
            const colorMap = {
                '#ef4444': 'Red',
                '#f97316': 'Orange',
                '#facc15': 'Yellow',
                '#10b981': 'Green',
                '#3b82f6': 'Blue',
                '#8b5cf6': 'Purple',
                '#000000': 'Black'
            };
            return colorMap[hex] || hex;
        }

        // Calculate centroid using shoelace formula
        // ============================================
        // ADAPTIVE CENTROID CALCULATION SYSTEM
        // ============================================
        
        // Helper: Calculate aspect ratio of bounding box
        function calculateAspectRatio(unitPoints) {
            if (unitPoints.length === 0) return 1.0;
            
            let minX = unitPoints[0].x, maxX = unitPoints[0].x;
            let minY = unitPoints[0].y, maxY = unitPoints[0].y;
            
            for (const p of unitPoints) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            }
            
            const width = maxX - minX;
            const height = maxY - minY;
            
            if (width === 0 || height === 0) return 1.0;
            
            return Math.max(width / height, height / width);
        }
        
        // Helper: Calculate density variance (how much point density varies)
        function calculateDensityVariance(unitPoints) {
            if (unitPoints.length < 5) return 0;
            
            const densities = [];
            const radius = 0.5; // Check within 0.5 unit radius
            
            for (let i = 0; i < unitPoints.length; i++) {
                let count = 0;
                for (let j = 0; j < unitPoints.length; j++) {
                    if (i === j) continue;
                    const dist = Math.sqrt(
                        (unitPoints[i].x - unitPoints[j].x) ** 2 + 
                        (unitPoints[i].y - unitPoints[j].y) ** 2
                    );
                    if (dist < radius) count++;
                }
                densities.push(count);
            }
            
            // Calculate coefficient of variation
            const mean = densities.reduce((sum, d) => sum + d, 0) / densities.length;
            if (mean === 0) return 0;
            
            const variance = densities.reduce((sum, d) => sum + (d - mean) ** 2, 0) / densities.length;
            return Math.sqrt(variance) / mean;
        }
        
        // Weighted Medoid: Points in dense areas have more influence
        function calculateWeightedMedoid(unitPoints, maxIterations = 50, tolerance = 0.001) {
            if (unitPoints.length < 3) {
                return calculateMedoid(unitPoints, maxIterations, tolerance);
            }
            
            // Calculate local density for each point
            const pointWeights = [];
            const neighborhoodRadius = 0.5;
            
            for (let i = 0; i < unitPoints.length; i++) {
                let neighborCount = 0;
                for (let j = 0; j < unitPoints.length; j++) {
                    if (i === j) continue;
                    const dist = Math.sqrt(
                        (unitPoints[i].x - unitPoints[j].x) ** 2 + 
                        (unitPoints[i].y - unitPoints[j].y) ** 2
                    );
                    if (dist < neighborhoodRadius) {
                        neighborCount++;
                    }
                }
                // More neighbors = higher weight (denser area)
                pointWeights.push(1 + neighborCount * 0.1);
            }
            
            // Initialize with weighted geometric centroid
            let totalWeight = pointWeights.reduce((sum, w) => sum + w, 0);
            let currentX = unitPoints.reduce((sum, p, i) => sum + p.x * pointWeights[i], 0) / totalWeight;
            let currentY = unitPoints.reduce((sum, p, i) => sum + p.y * pointWeights[i], 0) / totalWeight;
            
            // Weighted Weiszfeld's algorithm
            for (let iter = 0; iter < maxIterations; iter++) {
                let numeratorX = 0;
                let numeratorY = 0;
                let denominator = 0;
                
                for (let i = 0; i < unitPoints.length; i++) {
                    const p = unitPoints[i];
                    const dist = Math.sqrt((p.x - currentX) ** 2 + (p.y - currentY) ** 2);
                    
                    if (dist < 1e-10) continue;
                    
                    const weight = pointWeights[i] / dist;
                    numeratorX += p.x * weight;
                    numeratorY += p.y * weight;
                    denominator += weight;
                }
                
                if (denominator === 0) break;
                
                const newX = numeratorX / denominator;
                const newY = numeratorY / denominator;
                
                const change = Math.sqrt((newX - currentX) ** 2 + (newY - currentY) ** 2);
                
                currentX = newX;
                currentY = newY;
                
                if (change < tolerance) break;
            }
            
            return { x: currentX, y: currentY };
        }
        
        // Skeleton-Constrained: For elongated shapes, follows the "spine"
        function calculateSkeletonConstrainedCenter(unitPoints) {
            if (unitPoints.length < 10) {
                return calculateMedoid(unitPoints);
            }
            
            // Create skeleton points by averaging neighborhoods along path
            const skeletonPoints = [];
            const windowSize = Math.min(10, Math.floor(unitPoints.length / 5));
            
            for (let i = 0; i < unitPoints.length; i++) {
                let sumX = 0, sumY = 0, count = 0;
                
                for (let j = Math.max(0, i - windowSize); 
                     j < Math.min(unitPoints.length, i + windowSize + 1); 
                     j++) {
                    sumX += unitPoints[j].x;
                    sumY += unitPoints[j].y;
                    count++;
                }
                
                skeletonPoints.push({
                    x: sumX / count,
                    y: sumY / count
                });
            }
            
            // Calculate medoid of skeleton points
            return calculateMedoid(skeletonPoints);
        }
        
        // Brush-Aware: Accounts for visual mass of brush strokes
        function calculateBrushAwareMedoid(unitPoints, brushSize, maxIterations = 50) {
            const brushRadius = brushSize / SCALE_FACTOR / 2;
            
            // Create expanded points by sampling around each stroke point
            const expandedPoints = [];
            const angularSamples = 8; // Sample 8 points around each center
            
            // Limit sampling to avoid too many points (performance)
            const stride = Math.max(1, Math.floor(unitPoints.length / 100));
            
            for (let i = 0; i < unitPoints.length; i += stride) {
                const p = unitPoints[i];
                expandedPoints.push(p); // Include center
                
                // Add points around the circumference at brush radius
                for (let j = 0; j < angularSamples; j++) {
                    const angle = (j / angularSamples) * 2 * Math.PI;
                    expandedPoints.push({
                        x: p.x + brushRadius * Math.cos(angle),
                        y: p.y + brushRadius * Math.sin(angle)
                    });
                }
            }
            
            // Calculate medoid on expanded point set
            return calculateMedoid(expandedPoints, maxIterations, 0.001);
        }
        
        // Helper: Calculate area variation (how much visual area varies across shape)
        function calculateAreaVariation(unitPoints, brushSize) {
            if (unitPoints.length < 5) return 0;
            
            const brushRadius = brushSize / SCALE_FACTOR / 2;
            const areaContributions = [];
            
            // Calculate area contribution for each point
            for (let i = 0; i < unitPoints.length; i++) {
                let areaContribution = 0;
                
                // Base contribution: circle at this point
                const baseArea = Math.PI * brushRadius * brushRadius;
                areaContribution += baseArea;
                
                // Add contribution from segments
                if (i > 0) {
                    const p0 = unitPoints[i - 1];
                    const p1 = unitPoints[i];
                    const segmentLength = Math.sqrt(
                        (p1.x - p0.x) ** 2 + (p1.y - p0.y) ** 2
                    );
                    areaContribution += segmentLength * (brushRadius * 2) / 2;
                }
                
                if (i < unitPoints.length - 1) {
                    const p1 = unitPoints[i];
                    const p2 = unitPoints[i + 1];
                    const segmentLength = Math.sqrt(
                        (p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2
                    );
                    areaContribution += segmentLength * (brushRadius * 2) / 2;
                }
                
                areaContributions.push(areaContribution);
            }
            
            // Calculate coefficient of variation
            const mean = areaContributions.reduce((sum, a) => sum + a, 0) / areaContributions.length;
            if (mean === 0) return 0;
            
            const variance = areaContributions.reduce((sum, a) => sum + (a - mean) ** 2, 0) / areaContributions.length;
            return Math.sqrt(variance) / mean;
        }
        
        // Helper: Weighted Medoid with custom weights
        function calculateWeightedMedoidWithWeights(unitPoints, weights, maxIterations = 50, tolerance = 0.001) {
            if (unitPoints.length === 0) return { x: 0, y: 0 };
            if (unitPoints.length === 1) return { x: unitPoints[0].x, y: unitPoints[0].y };
            
            // Initialize with weighted geometric centroid
            let totalWeight = weights.reduce((sum, w) => sum + w, 0);
            let currentX = unitPoints.reduce((sum, p, i) => sum + p.x * weights[i], 0) / totalWeight;
            let currentY = unitPoints.reduce((sum, p, i) => sum + p.y * weights[i], 0) / totalWeight;
            
            // Weighted Weiszfeld's algorithm
            for (let iter = 0; iter < maxIterations; iter++) {
                let numeratorX = 0;
                let numeratorY = 0;
                let denominator = 0;
                
                for (let i = 0; i < unitPoints.length; i++) {
                    const p = unitPoints[i];
                    const dist = Math.sqrt((p.x - currentX) ** 2 + (p.y - currentY) ** 2);
                    
                    if (dist < 1e-10) continue;
                    
                    const weight = weights[i] / dist;
                    numeratorX += p.x * weight;
                    numeratorY += p.y * weight;
                    denominator += weight;
                }
                
                if (denominator === 0) break;
                
                const newX = numeratorX / denominator;
                const newY = numeratorY / denominator;
                
                const change = Math.sqrt((newX - currentX) ** 2 + (newY - currentY) ** 2);
                
                currentX = newX;
                currentY = newY;
                
                if (change < tolerance) break;
            }
            
            return { x: currentX, y: currentY };
        }
        
        // Area-Weighted Medoid: Points representing more visual area have more influence
        function calculateAreaWeightedMedoid(unitPoints, brushSize, maxIterations = 50) {
            if (unitPoints.length < 3) {
                return calculateMedoid(unitPoints, maxIterations, 0.001);
            }
            
            const brushRadius = brushSize / SCALE_FACTOR / 2;
            
            // Calculate area contribution for each point
            const weights = [];
            
            for (let i = 0; i < unitPoints.length; i++) {
                let areaContribution = 0;
                
                // Base contribution: circle at this point
                const baseArea = Math.PI * brushRadius * brushRadius;
                areaContribution += baseArea;
                
                // Add contribution from segments before this point
                if (i > 0) {
                    const p0 = unitPoints[i - 1];
                    const p1 = unitPoints[i];
                    const segmentLength = Math.sqrt(
                        (p1.x - p0.x) ** 2 + (p1.y - p0.y) ** 2
                    );
                    // Rectangle area of this segment
                    areaContribution += segmentLength * (brushRadius * 2) / 2;
                }
                
                // Add contribution from segments after this point
                if (i < unitPoints.length - 1) {
                    const p1 = unitPoints[i];
                    const p2 = unitPoints[i + 1];
                    const segmentLength = Math.sqrt(
                        (p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2
                    );
                    areaContribution += segmentLength * (brushRadius * 2) / 2;
                }
                
                weights.push(areaContribution);
            }
            
            // Normalize weights
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            const normalizedWeights = weights.map(w => w / totalWeight * unitPoints.length);
            
            // Calculate weighted medoid
            return calculateWeightedMedoidWithWeights(unitPoints, normalizedWeights, maxIterations, 0.001);
        }
        
        // Helper: Calculate concavity (how much the shape deviates from its convex hull)
        function calculateConcavity(unitPoints) {
            if (unitPoints.length < 10) return 0;
            
            // Calculate convex hull
            const hull = convexHull(unitPoints);
            
            if (hull.length < 3) return 0;
            
            // Calculate area of original shape (approximate)
            let shapeArea = 0;
            for (let i = 0; i < unitPoints.length; i++) {
                const p1 = unitPoints[i];
                const p2 = unitPoints[(i + 1) % unitPoints.length];
                shapeArea += p1.x * p2.y - p2.x * p1.y;
            }
            shapeArea = Math.abs(shapeArea) / 2;
            
            // Calculate area of convex hull
            let hullArea = 0;
            for (let i = 0; i < hull.length; i++) {
                const p1 = hull[i];
                const p2 = hull[(i + 1) % hull.length];
                hullArea += p1.x * p2.y - p2.x * p1.y;
            }
            hullArea = Math.abs(hullArea) / 2;
            
            if (hullArea === 0) return 0;
            
            // Concavity = 1 - (shape_area / hull_area)
            // 0 = convex, 1 = very concave
            return 1 - (shapeArea / hullArea);
        }
        
        // Convex Hull-Based Centroid for concave shapes (horseshoe, crescent)
        // ENHANCED: Now ensures centroid is always in visual center/bulk of shape
        function calculateConvexHullCentroid(unitPoints) {
            if (unitPoints.length < 10) {
                return calculateMedoid(unitPoints);
            }
            
            // Step 1: Calculate bounding box center as a starting point
            let minX = unitPoints[0].x, maxX = unitPoints[0].x;
            let minY = unitPoints[0].y, maxY = unitPoints[0].y;
            
            for (const p of unitPoints) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            }
            
            const bboxCenterX = (minX + maxX) / 2;
            const bboxCenterY = (minY + maxY) / 2;
            
            // Step 2: Calculate density-weighted center
            // This finds where most of the "mass" of the drawing is
            const gridResolution = 0.1;
            const densityMap = new Map();
            let maxDensity = 0;
            
            for (const p of unitPoints) {
                const gridX = Math.round(p.x / gridResolution);
                const gridY = Math.round(p.y / gridResolution);
                const key = `${gridX},${gridY}`;
                
                densityMap.set(key, (densityMap.get(key) || 0) + 1);
                maxDensity = Math.max(maxDensity, densityMap.get(key));
            }
            
            // Find center of mass based on density
            let densityCenterX = 0;
            let densityCenterY = 0;
            let totalWeight = 0;
            
            for (const [key, density] of densityMap.entries()) {
                const [gridX, gridY] = key.split(',').map(Number);
                const x = gridX * gridResolution;
                const y = gridY * gridResolution;
                
                densityCenterX += x * density;
                densityCenterY += y * density;
                totalWeight += density;
            }
            
            densityCenterX /= totalWeight;
            densityCenterY /= totalWeight;
            
            // Step 3: Calculate medoid (geometric median)
            const medoid = calculateMedoid(unitPoints);
            
            // Step 4: Combine all three measures with smart weighting
            // Bbox center (30%) + Density center (40%) + Medoid (30%)
            let visualCenterX = bboxCenterX * 0.30 + densityCenterX * 0.40 + medoid.x * 0.30;
            let visualCenterY = bboxCenterY * 0.30 + densityCenterY * 0.40 + medoid.y * 0.30;
            
            // Step 5: Verify the centroid is within the shape bounds
            // If it's outside or near an edge, pull it toward the densest region
            const isClosed = isShapeClosed(unitPoints);
            
            if (isClosed) {
                // For closed shapes, ensure centroid is inside the polygon
                let iterations = 0;
                while (iterations < 10 && !isPointInPolygon(visualCenterX, visualCenterY, unitPoints)) {
                    // Pull toward density center
                    visualCenterX = visualCenterX * 0.7 + densityCenterX * 0.3;
                    visualCenterY = visualCenterY * 0.7 + densityCenterY * 0.3;
                    iterations++;
                }
            }
            
            // Step 6: Final adjustment - ensure centroid is in "bulk" not near edges
            // Calculate distance to nearest edge point
            let minDistToEdge = Infinity;
            for (const p of unitPoints) {
                const dist = Math.sqrt((p.x - visualCenterX) ** 2 + (p.y - visualCenterY) ** 2);
                minDistToEdge = Math.min(minDistToEdge, dist);
            }
            
            // If too close to edge, pull more toward density center
            const avgDimension = (maxX - minX + maxY - minY) / 2;
            if (minDistToEdge < avgDimension * 0.15) {
                visualCenterX = visualCenterX * 0.5 + densityCenterX * 0.5;
                visualCenterY = visualCenterY * 0.5 + densityCenterY * 0.5;
            }
            
            return {
                x: visualCenterX,
                y: visualCenterY
            };
        }
        
        // Helper function: Check if point is inside polygon (ray casting algorithm)
        function isPointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        
        // ADAPTIVE CENTROID: Automatically chooses best method based on shape characteristics
        function calculateAdaptiveCentroid(unitPoints, brushSize) {
            if (unitPoints.length < 3) {
                if (unitPoints.length === 0) return { x: 0, y: 0 };
                if (unitPoints.length === 1) return { x: unitPoints[0].x, y: unitPoints[0].y };
                const avgX = unitPoints.reduce((sum, p) => sum + p.x, 0) / unitPoints.length;
                const avgY = unitPoints.reduce((sum, p) => sum + p.y, 0) / unitPoints.length;
                return { x: avgX, y: avgY };
            }
            
            // Analyze shape characteristics
            const aspectRatio = calculateAspectRatio(unitPoints);
            const densityVariance = calculateDensityVariance(unitPoints);
            const areaVariation = calculateAreaVariation(unitPoints, brushSize);
            const concavity = calculateConcavity(unitPoints);
            
            // Decision tree based on shape properties
            // PRIORITY: Use visual center (convex hull method) for most irregular shapes
            // LOWERED threshold from 0.2 to 0.15 to catch even MORE irregular shapes
            // This ensures centroid is in visual bulk for wider range of shapes
            
            if (concavity > 0.15 || densityVariance > 0.4) {
                // Concave, irregular, or shapes with uneven density
                // Examples: horseshoe, crescent, C-shape, U-shape, Pac-Man, irregular blobs
                // NEW: Also catches shapes with high density variance
                // Places centroid in the "bulk" or visual center
                return calculateConvexHullCentroid(unitPoints);
                
            } else if (aspectRatio > 3.0) {
                // Very elongated shape - use skeleton-constrained
                // Examples: snake-like curves, long arcs
                return calculateSkeletonConstrainedCenter(unitPoints);
                
            } else if (areaVariation > 0.3) {
                // Area variation detected - use area-weighted medoid
                // Examples: shapes with thickness variation
                return calculateAreaWeightedMedoid(unitPoints, brushSize);
                
            } else if (brushSize > 5) {
                // Thick strokes without area variation - use brush-aware medoid
                // Better represents visual mass
                return calculateBrushAwareMedoid(unitPoints, brushSize);
                
            } else if (densityVariance > 0.3) {
                // Moderate density variation - use weighted medoid
                // Examples: shapes with moderately dense and sparse regions
                return calculateWeightedMedoid(unitPoints);
                
            } else {
                // Very uniform, simple shape - basic medoid
                // Only reached for very simple, uniform shapes
                return calculateMedoid(unitPoints);
            }
        }
        
        // Medoid calculation using Weiszfeld's algorithm
        // Finds the point that minimizes sum of distances to all points
        // This guarantees the centroid is always inside or on the shape
        function calculateMedoid(unitPoints, maxIterations = 50, tolerance = 0.001) {
            if (unitPoints.length === 0) return { x: 0, y: 0 };
            if (unitPoints.length === 1) return { x: unitPoints[0].x, y: unitPoints[0].y };
            
            // Initialize with geometric centroid as starting point
            let currentX = unitPoints.reduce((sum, p) => sum + p.x, 0) / unitPoints.length;
            let currentY = unitPoints.reduce((sum, p) => sum + p.y, 0) / unitPoints.length;
            
            // Weiszfeld's algorithm - iterative refinement
            for (let iter = 0; iter < maxIterations; iter++) {
                let numeratorX = 0;
                let numeratorY = 0;
                let denominator = 0;
                
                for (const p of unitPoints) {
                    const dist = Math.sqrt((p.x - currentX) ** 2 + (p.y - currentY) ** 2);
                    
                    // Avoid division by zero
                    if (dist < 1e-10) continue;
                    
                    const weight = 1.0 / dist;
                    numeratorX += p.x * weight;
                    numeratorY += p.y * weight;
                    denominator += weight;
                }
                
                if (denominator === 0) break;
                
                const newX = numeratorX / denominator;
                const newY = numeratorY / denominator;
                
                // Check convergence
                const change = Math.sqrt((newX - currentX) ** 2 + (newY - currentY) ** 2);
                
                currentX = newX;
                currentY = newY;
                
                if (change < tolerance) break;
            }
            
            return { x: currentX, y: currentY };
        }

        // ============================================
        // ADAPTIVE AREA CALCULATION SYSTEM
        // ============================================
        
        // Helper: Calculate path length
        function calculatePathLength(unitPoints) {
            let length = 0;
            for (let i = 0; i < unitPoints.length - 1; i++) {
                const p1 = unitPoints[i];
                const p2 = unitPoints[i + 1];
                length += Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
            }
            return length;
        }
        
        // INTELLIGENT CLOSURE: Detect and complete common shapes
        function intelligentShapeClosure(unitPoints) {
            if (unitPoints.length < 20) return null; // Need enough points
            
            const first = unitPoints[0];
            const last = unitPoints[unitPoints.length - 1];
            const gapDistance = Math.sqrt((last.x - first.x) ** 2 + (last.y - first.y) ** 2);
            
            // Calculate path length
            const pathLength = calculatePathLength(unitPoints);
            
            // Check if shape is 50%+ closed (very lenient for partial shapes)
            const closureRatio = (pathLength - gapDistance) / pathLength;
            if (closureRatio < 0.50) return null; // Less than 50% traced = truly incomplete
            
            // Calculate bounding box
            let minX = unitPoints[0].x, maxX = unitPoints[0].x;
            let minY = unitPoints[0].y, maxY = unitPoints[0].y;
            
            for (const p of unitPoints) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            }
            
            const width = maxX - minX;
            const height = maxY - minY;
            const aspectRatio = Math.max(width, height) / Math.min(width, height);
            
            // Detect shape type based on characteristics
            const shapeType = detectShapeType(unitPoints, aspectRatio, width, height);
            
            if (shapeType === 'irregular') return null; // Don't close irregular shapes
            
            // Generate closing points based on shape type
            return generateClosingPath(shapeType, first, last, minX, maxX, minY, maxY, unitPoints);
        }
        
        function detectShapeType(points, aspectRatio, width, height) {
            // Check for irregularity (high variance in curvature)
            let curvatureVariance = 0;
            const segmentCount = Math.min(20, points.length - 1);
            const step = Math.floor(points.length / segmentCount);
            
            let angles = [];
            for (let i = step; i < points.length - step; i += step) {
                const p0 = points[i - step];
                const p1 = points[i];
                const p2 = points[i + step];
                
                const angle1 = Math.atan2(p1.y - p0.y, p1.x - p0.x);
                const angle2 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                let angleDiff = angle2 - angle1;
                
                // Normalize to [-œÄ, œÄ]
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                angles.push(Math.abs(angleDiff));
            }
            
            if (angles.length > 0) {
                const meanAngle = angles.reduce((a, b) => a + b, 0) / angles.length;
                curvatureVariance = angles.reduce((sum, a) => sum + (a - meanAngle) ** 2, 0) / angles.length;
            }
            
            // High variance = irregular shape
            if (curvatureVariance > 0.5) return 'irregular';
            
            // Check for crescent (concave shape)
            const isCrescent = detectCrescent(points);
            if (isCrescent) return 'crescent';
            
            // Check for half-circle (smooth arc with flat base)
            const isHalfCircle = detectHalfCircle(points, aspectRatio);
            if (isHalfCircle) return 'half-circle';
            
            // Circle/Oval: aspect ratio determines which
            if (aspectRatio < 1.3 && curvatureVariance < 0.1) {
                return 'circle';
            }
            
            if (aspectRatio >= 1.3 && aspectRatio < 2.5 && curvatureVariance < 0.15) {
                return 'oval';
            }
            
            // Diamond: rotated square (aspect ~1, 4 corners)
            if (aspectRatio < 1.4 && detectDiamondPattern(points)) {
                return 'diamond';
            }
            
            // Square: aspect ratio close to 1, low curvature variance
            if (aspectRatio < 1.3 && curvatureVariance < 0.3) {
                return 'square';
            }
            
            // Rectangle: elongated, low curvature variance
            if (aspectRatio >= 1.3 && aspectRatio < 3.5 && curvatureVariance < 0.3) {
                return 'rectangle';
            }
            
            // Triangle: 3 corners, specific angle pattern
            if (detectTrianglePattern(points)) {
                return 'triangle';
            }
            
            return 'irregular';
        }
        
        function detectHalfCircle(points, aspectRatio) {
            // Half-circle: aspect ratio ~2:1, one straight edge, one curved edge
            if (aspectRatio < 1.7 || aspectRatio > 2.5) return false;
            
            // Check if endpoints are roughly on same horizontal or vertical line
            const first = points[0];
            const last = points[points.length - 1];
            
            const horizontalGap = Math.abs(last.y - first.y);
            const verticalGap = Math.abs(last.x - first.x);
            
            // Calculate typical segment length
            const typicalSegment = calculatePathLength(points) / points.length;
            
            // If endpoints align horizontally or vertically (within 3 segments), it's a half-circle base
            return (horizontalGap < typicalSegment * 3) || (verticalGap < typicalSegment * 3);
        }
        
        function detectDiamondPattern(points) {
            // Diamond: 4 corners at roughly 90¬∞ angles
            let corners = [];
            const step = Math.max(5, Math.floor(points.length / 20));
            
            for (let i = step; i < points.length - step; i += step) {
                const p0 = points[i - step];
                const p1 = points[i];
                const p2 = points[i + step];
                
                const v1x = p1.x - p0.x, v1y = p1.y - p0.y;
                const v2x = p2.x - p1.x, v2y = p2.y - p1.y;
                
                const dot = v1x * v2x + v1y * v2y;
                const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
                const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
                
                if (mag1 > 0 && mag2 > 0) {
                    const angle = Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2))));
                    if (angle > Math.PI / 3) { // Corner detected
                        corners.push({index: i, angle: angle});
                    }
                }
            }
            
            // Diamond should have 4 corners
            return corners.length >= 3 && corners.length <= 5;
        }
        
        function detectCrescent(points) {
            // Crescent: concave shape - calculate if shape curves inward
            if (points.length < 30) return false;
            
            // Calculate convex hull and compare areas
            const hull = convexHull(points);
            if (hull.length < 3) return false;
            
            // Calculate hull area
            let hullArea = 0;
            for (let i = 0; i < hull.length; i++) {
                const p1 = hull[i];
                const p2 = hull[(i + 1) % hull.length];
                hullArea += p1.x * p2.y - p2.x * p1.y;
            }
            hullArea = Math.abs(hullArea) / 2;
            
            // Calculate path area (approximate)
            let pathArea = 0;
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                pathArea += p1.x * p2.y - p2.x * p1.y;
            }
            pathArea = Math.abs(pathArea) / 2;
            
            if (hullArea === 0) return false;
            
            // Concavity: if path area is much smaller than hull area, it's concave
            const concavity = 1 - (pathArea / hullArea);
            return concavity > 0.3; // Significant concavity = crescent
        }
        
        function detectTrianglePattern(points) {
            // Look for 3 distinct corners (high curvature points)
            let corners = 0;
            const step = Math.max(5, Math.floor(points.length / 20));
            
            for (let i = step; i < points.length - step; i += step) {
                const p0 = points[i - step];
                const p1 = points[i];
                const p2 = points[i + step];
                
                const v1x = p1.x - p0.x, v1y = p1.y - p0.y;
                const v2x = p2.x - p1.x, v2y = p2.y - p1.y;
                
                const dot = v1x * v2x + v1y * v2y;
                const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
                const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
                
                if (mag1 > 0 && mag2 > 0) {
                    const angle = Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2))));
                    if (angle > Math.PI / 4) { // Sharp corner
                        corners++;
                    }
                }
            }
            
            return corners >= 2 && corners <= 4; // 3 corners ¬± 1
        }
        
        function generateClosingPath(shapeType, start, end, minX, maxX, minY, maxY, originalPoints) {
            const closingPoints = [];
            
            if (shapeType === 'circle' || shapeType === 'oval') {
                // Close with elliptical arc
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const radiusX = (maxX - minX) / 2;
                const radiusY = (maxY - minY) / 2;
                
                const startAngle = Math.atan2((end.y - centerY) / radiusY, (end.x - centerX) / radiusX);
                const endAngle = Math.atan2((start.y - centerY) / radiusY, (start.x - centerX) / radiusX);
                
                let angle = startAngle;
                const steps = 10;
                let angleDiff = endAngle - startAngle;
                
                // Take shortest arc
                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                for (let i = 1; i < steps; i++) {
                    angle = startAngle + (angleDiff * i / steps);
                    closingPoints.push({
                        x: centerX + radiusX * Math.cos(angle),
                        y: centerY + radiusY * Math.sin(angle)
                    });
                }
            } else if (shapeType === 'half-circle') {
                // Close with straight line (flat base of half-circle)
                const steps = 5;
                for (let i = 1; i < steps; i++) {
                    const t = i / steps;
                    closingPoints.push({
                        x: end.x + (start.x - end.x) * t,
                        y: end.y + (start.y - end.y) * t
                    });
                }
            } else if (shapeType === 'diamond') {
                // Close with straight line (diamond edge)
                const steps = Math.max(3, Math.floor(Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2) / 0.1));
                for (let i = 1; i < steps; i++) {
                    const t = i / steps;
                    closingPoints.push({
                        x: end.x + (start.x - end.x) * t,
                        y: end.y + (start.y - end.y) * t
                    });
                }
            } else if (shapeType === 'crescent') {
                // Close with gentle curve (inner arc of crescent)
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                
                // Calculate control point for quadratic curve (slightly inward)
                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;
                
                // Pull control point toward center (creates inward curve)
                const controlX = midX + (centerX - midX) * 0.3;
                const controlY = midY + (centerY - midY) * 0.3;
                
                const steps = 10;
                for (let i = 1; i < steps; i++) {
                    const t = i / steps;
                    const oneMinusT = 1 - t;
                    
                    // Quadratic Bezier curve
                    const x = oneMinusT * oneMinusT * end.x + 
                             2 * oneMinusT * t * controlX + 
                             t * t * start.x;
                    const y = oneMinusT * oneMinusT * end.y + 
                             2 * oneMinusT * t * controlY + 
                             t * t * start.y;
                    
                    closingPoints.push({x, y});
                }
            } else if (shapeType === 'square' || shapeType === 'rectangle') {
                // Close with straight line (rectangle closes with straight edge)
                const steps = Math.max(3, Math.floor(Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2) / 0.1));
                for (let i = 1; i < steps; i++) {
                    const t = i / steps;
                    closingPoints.push({
                        x: end.x + (start.x - end.x) * t,
                        y: end.y + (start.y - end.y) * t
                    });
                }
            } else if (shapeType === 'triangle') {
                // Close with straight line
                closingPoints.push({
                    x: (end.x + start.x) / 2,
                    y: (end.y + start.y) / 2
                });
            }
            
            return closingPoints;
        }
        
        // Helper: Check if shape is closed (improved with multiple criteria)
        function isShapeClosed(unitPoints) {
            if (unitPoints.length < 10) return false;
            
            const first = unitPoints[0];
            const last = unitPoints[unitPoints.length - 1];
            
            const closureDistance = Math.sqrt(
                (last.x - first.x) ** 2 + (last.y - first.y) ** 2
            );
            
            // Calculate average segment length
            const pathLength = calculatePathLength(unitPoints);
            const avgSegment = pathLength / (unitPoints.length - 1);
            
            // DEBUG LOGGING
            console.log("=== CLOSURE DETECTION ===");
            console.log("Points:", unitPoints.length);
            console.log("Path length:", pathLength.toFixed(3), "units");
            console.log("Closure distance:", closureDistance.toFixed(3), "units");
            console.log("Avg segment:", avgSegment.toFixed(3), "units");
            console.log("Threshold (5x):", (avgSegment * 5.0).toFixed(3), "units");
            
            // Criterion 1: Direct closure check (extremely lenient)
            // Allow gap up to 15x average segment - handles most human imperfection
            const directClosure = closureDistance <= avgSegment * 15.0;
            
            if (directClosure) {
                console.log("‚úì CLOSED (Criterion 1: Direct closure)");
                return true;
            }
            
            // Criterion 2: Try intelligent closure for common shapes
            const closingPath = intelligentShapeClosure(unitPoints);
            if (closingPath && closingPath.length > 0) {
                console.log("‚úì CLOSED (Intelligent closure: shape completed)");
                // Add closing points to the original points
                for (const p of closingPath) {
                    unitPoints.push(p);
                }
                return true;
            }
            
            // Criterion 3: Rotation analysis
            // If shape rotates significantly, assume user intended closure
            if (closureDistance <= avgSegment * 20.0) {
                // Check if the path goes around (changes direction significantly)
                // Calculate total angle change along path
                let totalAngleChange = 0;
                
                for (let i = 1; i < unitPoints.length - 1; i++) {
                    const p0 = unitPoints[i - 1];
                    const p1 = unitPoints[i];
                    const p2 = unitPoints[i + 1];
                    
                    const v1x = p1.x - p0.x;
                    const v1y = p1.y - p0.y;
                    const v2x = p2.x - p1.x;
                    const v2y = p2.y - p1.y;
                    
                    const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
                    const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
                    
                    if (mag1 > 0 && mag2 > 0) {
                        const dot = v1x * v2x + v1y * v2y;
                        const cosAngle = dot / (mag1 * mag2);
                        const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));
                        totalAngleChange += angle;
                    }
                }
                
                // If total angle change is close to 2œÄ (360¬∞), it's a closed loop
                // Allow for approximately one full rotation (¬±50%)
                const fullRotation = 2 * Math.PI;
                if (totalAngleChange > fullRotation * 0.5) {
                    return true; // Likely intended as closed
                }
            }
            
            // Criterion 3: Check if bounding box suggests closed shape
            // If endpoints are far apart relative to bounding box, likely open
            let minX = unitPoints[0].x, maxX = unitPoints[0].x;
            let minY = unitPoints[0].y, maxY = unitPoints[0].y;
            
            for (const p of unitPoints) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            }
            
            const width = maxX - minX;
            const height = maxY - minY;
            const maxDimension = Math.max(width, height);
            
            // If closure gap is less than 50% of max dimension, treat as closed
            // This is extremely lenient - only truly open/incomplete shapes will fail
            // A 1√ó1 square can have gap up to 0.5 units and still close
            if (closureDistance < maxDimension * 0.50) {
                console.log("‚úì CLOSED (Criterion 4: Bounding box < 50%)");
                return true;
            }
            
            console.log("‚úó OPEN (all criteria failed - gap is unnaturally large)");
            return false;
        }
        
        // Method 1: Brush-Aware Ribbon Area (for open shapes or thin lines)
        function calculateBrushAwareArea(unitPoints, brushSize) {
            if (unitPoints.length < 2) return 0;
            
            const brushRadius = brushSize / SCALE_FACTOR / 2;
            
            // Calculate path length
            const pathLength = calculatePathLength(unitPoints);
            
            // Area = path length √ó brush diameter
            const ribbonArea = pathLength * (brushRadius * 2);
            
            // Add area of circular caps at endpoints
            const capArea = Math.PI * brushRadius * brushRadius * 2;
            
            return ribbonArea + capArea;
        }
        
        // Method 2: Pixel-Based Area (most accurate, for all shapes)
        function calculatePixelBasedArea(unitPoints, brushSize, resolution = null) {
            if (unitPoints.length === 0) return 0;
            
            // Calculate brush radius in units
            const isClosed = isShapeClosed(unitPoints);
            const fullBrushRadius = brushSize / SCALE_FACTOR / 2;
            
            // For closed shapes: include full interior + outline with full brush
            // For open shapes: use full brush radius for the stroke
            const brushRadius = fullBrushRadius;
            
            // DEBUG LOGGING
            console.log("=== AREA CALCULATION ===");
            console.log("Brush size (pixels):", brushSize);
            console.log("Brush radius (units):", brushRadius.toFixed(4));
            console.log("Brush diameter (units):", (brushRadius * 2).toFixed(4));
            console.log("Shape is CLOSED:", isClosed);
            
            // Adaptive resolution: use finer grid for thin brushes
            // This ensures we don't miss thin lines
            if (resolution === null) {
                if (brushRadius < 0.05) {
                    resolution = 0.05; // Finer resolution for very thin brushes
                } else if (brushRadius < 0.1) {
                    resolution = 0.075; // Medium-fine resolution
                } else {
                    resolution = 0.1; // Standard resolution for thick brushes
                }
            }
            
            console.log("Grid resolution:", resolution);
            
            // Find bounding box
            let minX = unitPoints[0].x, maxX = unitPoints[0].x;
            let minY = unitPoints[0].y, maxY = unitPoints[0].y;
            
            for (const p of unitPoints) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            }
            
            // Expand bounding box by brush radius
            minX -= brushRadius;
            maxX += brushRadius;
            minY -= brushRadius;
            maxY += brushRadius;
            
            // Sample grid and count "painted" cells
            let paintedCells = 0;
            
            for (let x = minX; x <= maxX; x += resolution) {
                for (let y = minY; y <= maxY; y += resolution) {
                    let isPainted = false;
                    
                    if (isClosed) {
                        // For closed shapes: include BOTH interior AND outline
                        // First check if inside polygon (INTERIOR AREA)
                        if (isPointInPolygon(x, y, unitPoints)) {
                            isPainted = true;
                        } else {
                            // Also check if within brush radius of path (OUTLINE)
                            for (const p of unitPoints) {
                                const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
                                if (dist <= brushRadius) {
                                    isPainted = true;
                                    break;
                                }
                            }
                        }
                    } else {
                        // For open shapes: only strokes matter (full radius)
                        for (const p of unitPoints) {
                            const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
                            if (dist <= brushRadius) {
                                isPainted = true;
                                break;
                            }
                        }
                    }
                    
                    if (isPainted) {
                        paintedCells++;
                    }
                }
            }
            
            // Area = number of cells √ó cell area
            const cellArea = resolution * resolution;
            const totalArea = paintedCells * cellArea;
            
            // POST-PROCESSING: For closed shapes, subtract most of the outline thickness
            // to get closer to the true interior area (grid square count)
            let adjustedArea = totalArea;
            
            if (isClosed) {
                // Calculate approximate perimeter for outline subtraction
                let perimeter = 0;
                for (let i = 0; i < unitPoints.length; i++) {
                    const p1 = unitPoints[i];
                    const p2 = unitPoints[(i + 1) % unitPoints.length];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    perimeter += Math.sqrt(dx * dx + dy * dy);
                }
                
                // Outline area contribution (approximate)
                // We subtract 90% of the outline to get close to pure interior area
                // This balances accuracy with discretization effects
                const outlineArea = perimeter * (brushRadius * 2) * 0.90;
                adjustedArea = Math.max(0, totalArea - outlineArea);
                
                console.log("Perimeter:", perimeter.toFixed(3), "units");
                console.log("Outline area (90%):", outlineArea.toFixed(4), "units¬≤");
                console.log("ADJUSTED AREA:", adjustedArea.toFixed(4), "units¬≤");
                console.log("(Subtracted 90% of outline)");
            }
            
            // DEBUG LOGGING
            console.log("Painted cells:", paintedCells);
            console.log("Cell area:", cellArea.toFixed(6), "units¬≤");
            console.log("RAW AREA:", totalArea.toFixed(4), "units¬≤");
            if (isClosed) {
                console.log("FINAL AREA (adjusted):", adjustedArea.toFixed(4), "units¬≤");
            } else {
                console.log("FINAL AREA:", adjustedArea.toFixed(4), "units¬≤");
            }
            console.log("========================");
            
            return adjustedArea;
        }
        
        // Helper: Point-in-polygon test using ray casting
        function isPointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        
        // Method 3: Hybrid Area (polygon + brush perimeter, for closed shapes)
        function calculateHybridArea(unitPoints, brushSize) {
            if (unitPoints.length < 3) {
                return calculateBrushAwareArea(unitPoints, brushSize);
            }
            
            const brushRadius = brushSize / SCALE_FACTOR / 2;
            
            // Calculate polygon area (interior)
            let polygonArea = 0;
            for (let i = 0; i < unitPoints.length; i++) {
                const p1 = unitPoints[i];
                const p2 = unitPoints[(i + 1) % unitPoints.length];
                polygonArea += p1.x * p2.y - p2.x * p1.y;
            }
            polygonArea = Math.abs(polygonArea) / 2;
            
            // Calculate perimeter length
            let perimeter = 0;
            for (let i = 0; i < unitPoints.length; i++) {
                const p1 = unitPoints[i];
                const p2 = unitPoints[(i + 1) % unitPoints.length];
                perimeter += Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
            }
            
            // Total area = polygon interior + perimeter band
            const perimeterBandArea = perimeter * brushRadius * 2;
            
            // Add approximate area of corners
            const cornerArea = Math.PI * brushRadius * brushRadius;
            
            return polygonArea + perimeterBandArea + cornerArea;
        }
        
        // Method 4: Pure Polygon Area (for very thin brushes)
        function calculatePolygonArea(unitPoints) {
            if (unitPoints.length < 3) return 0;
            
            let area = 0;
            for (let i = 0; i < unitPoints.length; i++) {
                const p1 = unitPoints[i];
                const p2 = unitPoints[(i + 1) % unitPoints.length];
                area += p1.x * p2.y - p2.x * p1.y;
            }
            return Math.abs(area) / 2;
        }
        
        // PIXEL-BASED AREA: Always uses pixel-based calculation for accuracy
        // 
        // POST-PROCESSING: For closed shapes, subtracts 90% of outline thickness
        // to get close to true interior area while accounting for corner effects
        //
        // Expected areas for different scenarios:
        // 
        // - Traced 1√ó1 grid square (closed, brush size 5px = 0.05 radius):
        //   Raw area ‚âà 1.4 units¬≤ (interior + outline)
        //   Adjusted area ‚âà 1.03-1.06 units¬≤ (after subtracting 90% of outline)
        //   ‚úì Very close to 1.0 grid square
        // 
        // - Traced 2√ó2 grid square (closed, brush size 5px):
        //   Raw area ‚âà 4.8 units¬≤
        //   Adjusted area ‚âà 4.06-4.12 units¬≤
        //   ‚úì Very close to 4.0 grid squares
        // 
        // - Traced 3√ó3 grid square (closed, brush size 5px):
        //   Raw area ‚âà 10.2 units¬≤
        //   Adjusted area ‚âà 9.12-9.18 units¬≤
        //   ‚úì Very close to 9.0 grid squares
        // 
        // - Traced outline (open, brush size 5px):
        //   Area ‚âà perimeter √ó brush_diameter
        //   No adjustment (outline is the actual shape)
        //
        // Note: Uses adaptive resolution based on brush size for accuracy
        //
        function calculateAdaptiveArea(unitPoints, brushSize) {
            if (unitPoints.length < 2) return 0;
            
            // Use adaptive resolution (null = auto-select based on brush size)
            // This ensures thin strokes are captured accurately
            // Post-processing will adjust closed shapes to subtract 90% of outline
            return calculatePixelBasedArea(unitPoints, brushSize, null);
        }
        
        // ============================================
        // MULTI-SHAPE DETECTION SYSTEM
        // ============================================
        
        // Detect disconnected components in a drawn path
        function detectDisconnectedComponents(points, maxGap = 2.0) {
            if (points.length < 3) return [points];
            
            const unitPoints = points.map(p => canvasToUnit(p.x, p.y));
            const components = [];
            let currentComponent = [unitPoints[0]];
            
            for (let i = 1; i < unitPoints.length; i++) {
                const p1 = unitPoints[i - 1];
                const p2 = unitPoints[i];
                
                const gap = Math.sqrt(
                    (p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2
                );
                
                // If gap is large, start new component
                if (gap > maxGap) {
                    // Save previous component if substantial
                    if (currentComponent.length >= 10) {
                        components.push(currentComponent);
                    }
                    // Start new component
                    currentComponent = [p2];
                } else {
                    currentComponent.push(p2);
                }
            }
            
            // Add final component
            if (currentComponent.length >= 10) {
                components.push(currentComponent);
            }
            
            return components.length > 0 ? components : [unitPoints];
        }
        
        // Calculate combined area and averaged centroid for multiple components
        function calculateMultiComponentMetrics(components, brushSize, areaThreshold = 0.5) {
            const validComponents = [];
            
            // Calculate area and centroid for each component
            for (const component of components) {
                if (component.length < 3) continue;
                
                const area = calculateAdaptiveArea(component, brushSize);
                
                // Only include components with area >= threshold
                if (area >= areaThreshold) {
                    const centroid = calculateAdaptiveCentroid(component, brushSize);
                    validComponents.push({
                        points: component,
                        area: area,
                        centroid: centroid
                    });
                }
            }
            
            // If no valid components, return zero
            if (validComponents.length === 0) {
                return { area: 0, x: 0, y: 0, componentCount: 0 };
            }
            
            // Sum all areas
            const totalArea = validComponents.reduce((sum, comp) => sum + comp.area, 0);
            
            // Average centroids (unweighted - each component contributes equally)
            const avgX = validComponents.reduce((sum, comp) => sum + comp.centroid.x, 0) / validComponents.length;
            const avgY = validComponents.reduce((sum, comp) => sum + comp.centroid.y, 0) / validComponents.length;
            
            return {
                area: totalArea,
                x: avgX,
                y: avgY,
                componentCount: validComponents.length
            };
        }

        // Adaptive area calculation - automatically detects open vs closed shapes
        function convexHull(points) {
            if (points.length <= 3) return points;
            
            // Sort points by x-coordinate (and y if x is equal)
            const sorted = points.slice().sort((a, b) => 
                a.x === b.x ? a.y - b.y : a.x - b.x
            );
            
            // Cross product to determine turn direction
            const cross = (o, a, b) => 
                (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
            
            // Build lower hull
            const lower = [];
            for (const p of sorted) {
                while (lower.length >= 2 && 
                       cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                    lower.pop();
                }
                lower.push(p);
            }
            
            // Build upper hull
            const upper = [];
            for (let i = sorted.length - 1; i >= 0; i--) {
                const p = sorted[i];
                while (upper.length >= 2 && 
                       cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                    upper.pop();
                }
                upper.push(p);
            }
            
            // Remove last point of each half because it's repeated
            lower.pop();
            upper.pop();
            
            return lower.concat(upper);
        }

        // Calculate area and centroid using Adaptive methods for both
        function calculatePolygonAreaAndCentroid(polygonPoints) {
            if (polygonPoints.length < 3) return { area: 0, x: 0, y: 0 };
            
            // Calculate area using Adaptive Area method
            const area = calculateAdaptiveArea(polygonPoints, brushSize);
            
            // Calculate centroid using Adaptive Centroid method
            const adaptiveCenter = calculateAdaptiveCentroid(polygonPoints, brushSize);
            
            return { area, x: adaptiveCenter.x, y: adaptiveCenter.y };
        }

        // Adaptive area calculation - automatically detects open vs closed shapes
        function calculateCentroid(points) {
            if (points.length < 3) return { area: 0, x: 0, y: 0 };
            
            // STEP 1: Detect disconnected components (for "two ears" case)
            const components = detectDisconnectedComponents(points, 2.0);
            
            // STEP 2: If multiple components detected, combine them
            if (components.length > 1) {
                const result = calculateMultiComponentMetrics(components, brushSize, 0.5);
                return result;
            }
            
            // STEP 3: Single component - proceed with normal calculation
            const unitPoints = points.map(p => canvasToUnit(p.x, p.y));
            
            // Calculate closure distance
            const first = unitPoints[0];
            const last = unitPoints[unitPoints.length - 1];
            const closureDistance = Math.sqrt(
                (last.x - first.x) ** 2 + (last.y - first.y) ** 2
            );
            
            // Calculate average segment length for reference
            let totalSegmentLength = 0;
            for (let i = 0; i < unitPoints.length - 1; i++) {
                const p1 = unitPoints[i];
                const p2 = unitPoints[i + 1];
                const segmentLength = Math.sqrt(
                    (p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2
                );
                totalSegmentLength += segmentLength;
            }
            const avgSegmentLength = totalSegmentLength / (unitPoints.length - 1);
            
            // Threshold: if endpoints are within 2x average segment length, treat as closed
            // This is tunable - increase for stricter closure requirements
            const closureThreshold = avgSegmentLength * 2.0;
            
            if (closureDistance <= closureThreshold) {
                // Shape appears closed - use Adaptive Area calculation
                const area = calculateAdaptiveArea(unitPoints, brushSize);
                
                // Calculate centroid using Adaptive method (automatically chooses best algorithm)
                const adaptiveCenter = calculateAdaptiveCentroid(unitPoints, brushSize);
                
                return { area, x: adaptiveCenter.x, y: adaptiveCenter.y };
            } else {
                // Shape is clearly open - use convex hull for more natural area calculation
                const hull = convexHull(unitPoints);
                return calculatePolygonAreaAndCentroid(hull);
            }
        }

        // Drawing functions
        
        // Draws a circle with a radius of 3 units, always in the background
        function drawBackgroundCircle() {
            const center = CANVAS_SIZE / 2;
            // Radius in pixels: 3 units * SCALE_FACTOR (50 pixels/unit) = 150 pixels
            const radiusPixels = BACKGROUND_CIRCLE_RADIUS_UNITS * SCALE_FACTOR; 
            
            ctx.save();
            
            ctx.beginPath();
            ctx.arc(center, center, radiusPixels, 0, 2 * Math.PI);
            
            // Subtle color for the background element
            ctx.strokeStyle = '#9ca3af'; // Same as axis color
            ctx.lineWidth = 2;
            
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawGrid() {
            const center = CANVAS_SIZE / 2;
            const gridColor = '#e5e7eb';
            const axisColor = '#9ca3af';
            const labelColor = '#6b7280';
            
            ctx.save();
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            
            // Draw grid lines
            for (let i = -UNIT_RANGE + 1; i < UNIT_RANGE; i++) {
                const coord = unitToCanvas(i, i);
                
                if (i !== 0) {
                    ctx.beginPath();
                    ctx.moveTo(0, coord.y);
                    ctx.lineTo(CANVAS_SIZE, coord.y);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(coord.x, 0);
                    ctx.lineTo(coord.x, CANVAS_SIZE);
                    ctx.stroke();
                }
            }
            
            // Draw axes
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, center);
            ctx.lineTo(CANVAS_SIZE, center);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(center, 0);
            ctx.lineTo(center, CANVAS_SIZE);
            ctx.stroke();

            // Draw labels - with better positioning to avoid cutoff
            ctx.fillStyle = labelColor;
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw X-axis labels (horizontal)
            for (let i = -UNIT_RANGE; i <= UNIT_RANGE; i += 2) {
                if (i === 0) continue;
                const coord = unitToCanvas(i, 0);
                // Position labels slightly higher to avoid cutoff at bottom
                const labelY = i === UNIT_RANGE || i === -UNIT_RANGE ? center + 25 : center + 20;
                ctx.fillText(i.toString(), coord.x, labelY);
            }
            
            // Draw Y-axis labels (vertical)
            for (let j = -UNIT_RANGE; j <= UNIT_RANGE; j += 2) {
                if (j === 0) continue;
                const coord = unitToCanvas(0, j);
                // Adjust alignment for extreme values to prevent cutoff
                if (j === UNIT_RANGE) {
                    ctx.textAlign = 'left';
                    ctx.fillText(j.toString(), center + 10, coord.y);
                } else if (j === -UNIT_RANGE) {
                    ctx.textAlign = 'left';
                    ctx.fillText(j.toString(), center + 10, coord.y);
                } else {
                    ctx.textAlign = 'left';
                    ctx.fillText(j.toString(), center + 8, coord.y);
                }
            }
            
            ctx.textAlign = 'right';
            ctx.fillText('0', center - 8, center + 20);

            // Draw center point
            ctx.fillStyle = '#1e40af';
            ctx.beginPath();
            ctx.arc(center, center, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawCentroidMarker(centroidX, centroidY, color) {
            const pos = unitToCanvas(centroidX, centroidY);
            const markerSize = 12;
            
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            
            // Draw cross
            ctx.beginPath();
            ctx.moveTo(pos.x - markerSize, pos.y);
            ctx.lineTo(pos.x + markerSize, pos.y);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y - markerSize);
            ctx.lineTo(pos.x, pos.y + markerSize);
            ctx.stroke();
            
            // Draw circle
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, markerSize + 2, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Helper function to draw grid on any context
        function drawGridOnContext(context) {
            const center = CANVAS_SIZE / 2;
            const gridColor = '#e5e7eb';
            const axisColor = '#9ca3af';
            const labelColor = '#6b7280';
            
            context.save();
            context.strokeStyle = gridColor;
            context.lineWidth = 1;
            
            // Draw grid lines
            for (let i = -UNIT_RANGE + 1; i < UNIT_RANGE; i++) {
                const coord = unitToCanvas(i, i);
                
                if (i !== 0) {
                    context.beginPath();
                    context.moveTo(0, coord.y);
                    context.lineTo(CANVAS_SIZE, coord.y);
                    context.stroke();
                    
                    context.beginPath();
                    context.moveTo(coord.x, 0);
                    context.lineTo(coord.x, CANVAS_SIZE);
                    context.stroke();
                }
            }
            
            // Draw axes
            context.strokeStyle = axisColor;
            context.lineWidth = 2;
            
            context.beginPath();
            context.moveTo(0, center);
            context.lineTo(CANVAS_SIZE, center);
            context.stroke();

            context.beginPath();
            context.moveTo(center, 0);
            context.lineTo(center, CANVAS_SIZE);
            context.stroke();

            // Draw labels - with better positioning to avoid cutoff
            context.fillStyle = labelColor;
            context.font = 'bold 12px sans-serif';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Draw X-axis labels (horizontal)
            for (let i = -UNIT_RANGE; i <= UNIT_RANGE; i += 2) {
                if (i === 0) continue;
                const coord = unitToCanvas(i, 0);
                // Position labels slightly higher to avoid cutoff at bottom
                const labelY = i === UNIT_RANGE || i === -UNIT_RANGE ? center + 25 : center + 20;
                context.fillText(i.toString(), coord.x, labelY);
            }
            
            // Draw Y-axis labels (vertical)
            for (let j = -UNIT_RANGE; j <= UNIT_RANGE; j += 2) {
                if (j === 0) continue;
                const coord = unitToCanvas(0, j);
                // Adjust alignment for extreme values to prevent cutoff
                if (j === UNIT_RANGE) {
                    context.textAlign = 'left';
                    context.fillText(j.toString(), center + 10, coord.y);
                } else if (j === -UNIT_RANGE) {
                    context.textAlign = 'left';
                    context.fillText(j.toString(), center + 10, coord.y);
                } else {
                    context.textAlign = 'left';
                    context.fillText(j.toString(), center + 8, coord.y);
                }
            }
            
            context.textAlign = 'right';
            context.fillText('0', center - 8, center + 20);

            // Draw center point
            context.fillStyle = '#1e40af';
            context.beginPath();
            context.arc(center, center, 5, 0, Math.PI * 2);
            context.fill();

            context.restore();
        }
        
        // Helper function to draw centroid marker on any context
        function drawCentroidMarkerOnContext(context, centroidX, centroidY, color) {
            const pos = unitToCanvas(centroidX, centroidY);
            const markerSize = 12;
            
            context.save();
            context.strokeStyle = color;
            context.lineWidth = 3;
            context.lineCap = 'round';
            
            // Draw cross
            context.beginPath();
            context.moveTo(pos.x - markerSize, pos.y);
            context.lineTo(pos.x + markerSize, pos.y);
            context.stroke();
            
            context.beginPath();
            context.moveTo(pos.x, pos.y - markerSize);
            context.lineTo(pos.x, pos.y + markerSize);
            context.stroke();
            
            // Draw circle
            context.lineWidth = 2;
            context.beginPath();
            context.arc(pos.x, pos.y, markerSize + 2, 0, Math.PI * 2);
            context.stroke();
            
            context.restore();
        }
        
        // Generate image for a specific frequency
        function generateImageForFrequency(freq) {
            const key = getFrequencyKey(freq);
            const shapes = allFrequencyData[key];
            
            // Create a temporary canvas for this frequency
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = CANVAS_SIZE;
            tempCanvas.height = CANVAS_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            
            // White background
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Draw background image if exists
            if (backgroundImage) {
                tempCtx.drawImage(backgroundImage, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }
            
            // Draw the background circle
            const center = CANVAS_SIZE / 2;
            const radiusPixels = BACKGROUND_CIRCLE_RADIUS_UNITS * SCALE_FACTOR;
            tempCtx.save();
            tempCtx.beginPath();
            tempCtx.arc(center, center, radiusPixels, 0, 2 * Math.PI);
            tempCtx.strokeStyle = '#9ca3af';
            tempCtx.lineWidth = 2;
            tempCtx.stroke();
            tempCtx.restore();
            
            // Draw grid
            drawGridOnContext(tempCtx);
            
            // Draw shapes for this frequency
            shapes.forEach(path => {
                if (path.length < 2) return;
                
                tempCtx.beginPath();
                tempCtx.lineJoin = 'round';
                tempCtx.lineCap = 'round';
                tempCtx.moveTo(path[0].x, path[0].y);

                for (let i = 1; i < path.length; i++) {
                    const p = path[i];
                    tempCtx.lineWidth = p.size;
                    tempCtx.strokeStyle = p.color;
                    tempCtx.lineTo(p.x, p.y);
                }
                tempCtx.stroke();
                
                // Draw centroid marker
                const { x, y } = calculateCentroid(path);
                drawCentroidMarkerOnContext(tempCtx, x, y, path[0].color);
            });
            
            return tempCanvas.toDataURL('image/png');
        }
        
        // NEW FUNCTION: Manages the chronological count for a participant
        function getAndIncrementParticipantExportCount(participantName) {
            // If no name is provided, default to '01' and do not save
            if (!participantName || participantName === 'P-Anonymous') {
                return '01';
            }

            // Sanitize key for localStorage
            const storageKey = `exportCount_${participantName.replace(/[^a-zA-Z0-9]/g, '_')}`;
            
            // Get current count (or 0 if not found)
            let currentCount = parseInt(localStorage.getItem(storageKey) || '0');
            
            // Increment for the current export
            const newCount = currentCount + 1;
            
            // Save the new count
            localStorage.setItem(storageKey, newCount.toString());
            
            // Return the formatted new count (e.g., 1 -> '01', 12 -> '12')
            return String(newCount).padStart(2, '0');
        }

        // MODIFIED: Function to download all drawings as a ZIP file with chronological naming
        function downloadAllImagesAsZip() {
            // Check for JSZip and FileSaver dependency
            if (typeof JSZip === 'undefined' || typeof saveAs === 'undefined') {
                alert('ZIP functionality libraries are not loaded correctly.');
                return;
            }

            const participantName = document.getElementById('participant-name').value.trim() || 'P-Anonymous';
            
            // Check if we have any drawings
            let hasDrawings = false;
            for (const key in allFrequencyData) {
                if (allFrequencyData[key].length > 0) {
                    hasDrawings = true;
                    break;
                }
            }
            
            if (!hasDrawings) {
                alert('No drawings found. Please draw shapes for at least one frequency to create a zip file.');
                return;
            }
            
            // GET AND INCREMENT CHRONOLOGICAL COUNT
            const chronologicalCount = getAndIncrementParticipantExportCount(participantName);
            
            document.getElementById('status-message').textContent = 'Status: Generating ZIP file...';
            
            const zip = new JSZip();
            // Use the chronological count in the folder name
            const folderName = `${participantName}_${chronologicalCount}_Drawings`; 
            const folder = zip.folder(folderName);
            
            let filesAdded = 0;

            for (const freq of frequencies) {
                const key = getFrequencyKey(freq);
                if (allFrequencyData[key].length > 0) {
                    const dataURL = generateImageForFrequency(freq);
                    const filename = `${participantName}_${freq.hz}Hz_${freq.db}dB.png`;
                    // Data URL is in the format: data:image/png;base64,iVBORw0KGgo...
                    const base64Data = dataURL.split(',')[1];
                    
                    folder.file(filename, base64Data, { base64: true });
                    filesAdded++;
                }
            }
            
            if (filesAdded === 0) {
                 // This should not happen due to previous check, but handle it
                 document.getElementById('status-message').textContent = 'Status: No drawings found to zip.';
                 return;
            }
            
            // Generate the ZIP file
            zip.generateAsync({ type: "blob" })
                .then(function(content) {
                    // Use the chronological count in the final ZIP filename
                    saveAs(content, `${participantName}_${chronologicalCount}_Drawings.zip`);
                    document.getElementById('status-message').textContent = `Status: Successfully generated and downloaded ${filesAdded} images in ZIP file ${chronologicalCount}.`;
                })
                .catch(error => {
                    console.error('ZIP generation error:', error);
                    document.getElementById('status-message').textContent = 'Status: ZIP generation failed';
                    alert('An error occurred during ZIP file generation. Check console for details.');
                });
        }
        
        function redrawCanvas() {
            const shapes = getCurrentShapes();
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }
            
            // Draw the background circle first
            drawBackgroundCircle(); 
            
            drawGrid();

            shapes.forEach(path => {
                if (path.length < 2) return;
                
                ctx.beginPath();
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.moveTo(path[0].x, path[0].y);

                for (let i = 1; i < path.length; i++) {
                    const p = path[i];
                    ctx.lineWidth = p.size;
                    ctx.strokeStyle = p.color;
                    ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
                
                const { x, y } = calculateCentroid(path);
                drawCentroidMarker(x, y, path[0].color);
            });

            updateUndoRedoButtons();
        }

        // Analysis and display
        function runAnalysis() {
            const shapes = getCurrentShapes();
            const results = [];

            shapes.forEach((path, index) => {
                const { area, x, y } = calculateCentroid(path);
                results.push({
                    id: index + 1,
                    color: path[0].color,
                    area: area,
                    centroidX: x,
                    centroidY: y
                });
            });

            displayAnalysisResults(results);
            return results;
        }

        function displayAnalysisResults(results) {
            const container = document.getElementById('results-table-container');
            if (results.length === 0) {
                container.innerHTML = '<p class="text-gray-500 italic">Draw shapes for this frequency to see results.</p>';
                return;
            }

            let html = `
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-blue-50">
                            <tr>
                                <th class="px-3 py-2 text-left text-xs font-medium text-blue-700 uppercase">#</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-blue-700 uppercase">Color</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-blue-700 uppercase">Area (Grid Squares)</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-blue-700 uppercase">Centroid X</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-blue-700 uppercase">Centroid Y</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
            `;

            results.forEach(r => {
                html += `
                    <tr>
                        <td class="px-3 py-2 text-sm font-medium">${r.id}</td>
                        <td class="px-3 py-2 text-sm">
                            <div class="w-5 h-5 rounded-full" style="background-color: ${r.color}; border: 1px solid #ccc;"></div>
                        </td>
                        <td class="px-3 py-2 text-sm font-mono">${r.area.toFixed(3)}</td>
                        <td class="px-3 py-2 text-sm font-mono">${r.centroidX.toFixed(3)}</td>
                        <td class="px-3 py-2 text-sm font-mono">${r.centroidY.toFixed(3)}</td>
                    </tr>
                `;
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // Undo/Redo functionality
        function saveState() {
            const key = getFrequencyKey(currentFrequency);
            undoStacks[key].push(JSON.stringify(getCurrentShapes()));
            redoStacks[key] = [];
            updateUndoRedoButtons();
        }

        function undo() {
            const key = getFrequencyKey(currentFrequency);
            if (undoStacks[key].length > 0) {
                redoStacks[key].push(JSON.stringify(getCurrentShapes()));
                const prevState = JSON.parse(undoStacks[key].pop());
                allFrequencyData[key] = prevState;
                redrawCanvas();
                runAnalysis();
            }
        }

        function redo() {
            const key = getFrequencyKey(currentFrequency);
            if (redoStacks[key].length > 0) {
                undoStacks[key].push(JSON.stringify(getCurrentShapes()));
                const nextState = JSON.parse(redoStacks[key].pop());
                allFrequencyData[key] = nextState;
                redrawCanvas();
                runAnalysis();
            }
        }

        function updateUndoRedoButtons() {
            const key = getFrequencyKey(currentFrequency);
            document.getElementById('undo-button').disabled = undoStacks[key].length === 0;
            document.getElementById('redo-button').disabled = redoStacks[key].length === 0;
        }

        // Drawing event handlers
        function getEventPoint(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            return {
                x: (clientX - rect.left) * (CANVAS_SIZE / rect.width),
                y: (clientY - rect.top) * (CANVAS_SIZE / rect.height)
            };
        }

        function startDrawing(e) {
            if (!isDrawing) return;
            isPainting = true;
            saveState();

            const point = getEventPoint(e);
            currentPath = [{ x: point.x, y: point.y, color: selectedColor.hex, size: brushSize }];
            
            ctx.beginPath();
            ctx.moveTo(point.x, point.y);
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = selectedColor.hex;

            e.preventDefault();
        }

        function draw(e) {
            if (!isPainting || !isDrawing) return;

            const point = getEventPoint(e);
            currentPath.push({ x: point.x, y: point.y, color: selectedColor.hex, size: brushSize });

            ctx.lineTo(point.x, point.y);
            ctx.stroke();
            e.preventDefault();
        }

        function stopDrawing() {
            if (!isPainting) return;
            isPainting = false;
            ctx.closePath();

            if (currentPath.length > 1) {
                const currentShapes = getCurrentShapes();
                currentShapes.push(currentPath);
                redrawCanvas();
                runAnalysis();
            } else {
                undoStacks[getFrequencyKey(currentFrequency)].pop();
                updateUndoRedoButtons();
            }

            currentPath = [];
        }

        // UI creation functions
        function createFrequencyTabs() {
            const container = document.getElementById('frequency-tabs');
            container.innerHTML = '';
            
            frequencies.forEach((freq) => {
                const key = getFrequencyKey(freq);
                const button = document.createElement('button');
                button.className = 'frequency-tab px-4 py-2 rounded-xl font-bold transition-all text-sm bg-gray-100 text-gray-700';
                button.textContent = `${freq.hz} Hz (${freq.db} dB)`;
                button.dataset.key = key;
                
                button.addEventListener('click', () => {
                    currentFrequency = freq;
                    document.querySelectorAll('.frequency-tab').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');
                    redrawCanvas();
                    runAnalysis();
                    document.getElementById('status-message').textContent = `Status: Switched to ${freq.hz} Hz at ${freq.db} dB`;
                });
                
                container.appendChild(button);
            });
            
            container.querySelector('button')?.click();
        }

        function createColorPalette() {
            const container = document.getElementById('color-palette');
            container.innerHTML = '';
            
            colors.forEach((color, index) => {
                const button = document.createElement('button');
                button.className = 'color-button w-14 h-14 rounded-full shadow-md transition-all transform hover:scale-110 border-4 border-gray-200';
                button.style.backgroundColor = color.hex;
                button.title = color.name;
                
                if (index === 0) button.classList.add('selected');
                
                button.addEventListener('click', () => {
                    document.querySelectorAll('.color-button').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                    selectedColor = color;
                    document.getElementById('status-message').textContent = `Status: Color set to ${color.name}`;
                });
                
                container.appendChild(button);
            });
        }

        // File operations
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        backgroundImage = img;
                        redrawCanvas();
                        document.getElementById('status-message').textContent = 'Status: Background image loaded successfully';
                    }
                    img.onerror = function() {
                        backgroundImage = null;
                        document.getElementById('status-message').textContent = 'Status: Error loading image';
                    }
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function exportCSV() {
            const name = document.getElementById('participant-name').value || 'P-Anonymous';
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Participant,Frequency_Hz,Frequency_dB,Shape_ID,Color_Hex,Area_Grid_Squares,Centroid_X,Centroid_Y,Total_Points,Raw_Path_Coordinates\n";
            
            for (const key in allFrequencyData) {
                const freqInfo = frequencies.find(f => getFrequencyKey(f) === key);
                if (!freqInfo) continue;

                const shapes = allFrequencyData[key];
                shapes.forEach((path, index) => {
                    const { area, x, y } = calculateCentroid(path);
                    const rawCoords = path.map(p => {
                        const unitPoint = canvasToUnit(p.x, p.y);
                        return `${unitPoint.x.toFixed(3)},${unitPoint.y.toFixed(3)}`;
                    }).join('|');
                    
                    csvContent += `${name},${freqInfo.hz},${freqInfo.db},${index + 1},${path[0].color},${area.toFixed(4)},${x.toFixed(4)},${y.toFixed(4)},${path.length},"${rawCoords}"\n`;
                });
            }

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `${name}_sound_object_data.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            document.getElementById('status-message').textContent = 'Status: All data exported to CSV';
        }

        async function exportToGoogleSheets() {
            const participantName = document.getElementById('participant-name').value.trim();
            if (!participantName) {
                alert('Please enter your name before exporting.');
                return;
            }

            const urlInput = document.getElementById('sheets-url-input');
            const sheetsUrl = urlInput.value.trim();
            
            if (!sheetsUrl) {
                alert('Please enter your Google Apps Script Web App URL.');
                return;
            }
            
            localStorage.setItem('sheetsUrl', sheetsUrl);

            let allShapes = [];
            frequencies.forEach(freq => {
                const key = getFrequencyKey(freq);
                const shapes = allFrequencyData[key];
                shapes.forEach(shape => {
                    const { area, x, y } = calculateCentroid(shape);
                    allShapes.push({
                        frequency: freq.hz,
                        dbSPL: freq.db,
                        color: hexToColorName(shape[0].color),
                        area: area.toFixed(4),
                        centroidX: x.toFixed(4),
                        centroidY: y.toFixed(4)
                    });
                });
            });

            if (allShapes.length === 0) {
                alert('No data to export. Please draw some shapes first.');
                return;
            }

            const data = {
                participant: participantName,
                shapes: allShapes
            };

            try {
                document.getElementById('status-message').textContent = 'Status: Exporting to Google Sheets...';
                // Using fetch with no-cors mode, expecting success but may not get response details
                await fetch(sheetsUrl, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                document.getElementById('status-message').textContent = 'Status: Data exported successfully!';
                alert('Data exported successfully to Google Sheets! (Check your sheet in a moment)');
            } catch (error) {
                console.error('Export error:', error);
                document.getElementById('status-message').textContent = 'Status: Export failed';
                alert('Export failed. Please check your Web App URL and ensure CORS is configured for POST requests.');
            }
        }

        async function exportToGoogleDrive() {
            // Check for JSZip dependency
            if (typeof JSZip === 'undefined') {
                alert('ZIP functionality library is not loaded correctly.');
                return;
            }

            const participantName = document.getElementById('participant-name').value.trim();
            if (!participantName) {
                alert('Please enter your name before exporting.');
                return;
            }

            const urlInput = document.getElementById('drive-url-input');
            const driveUrl = urlInput.value.trim();
            
            if (!driveUrl) {
                alert('Please enter your Google Apps Script Web App URL for Drive export.');
                return;
            }
            
            localStorage.setItem('driveUrl', driveUrl);

            // Check if we have any drawings
            let hasDrawings = false;
            for (const key in allFrequencyData) {
                if (allFrequencyData[key].length > 0) {
                    hasDrawings = true;
                    break;
                }
            }
            
            if (!hasDrawings) {
                alert('No drawings found. Please draw shapes for at least one frequency.');
                return;
            }

            document.getElementById('status-message').textContent = 'Status: Generating ZIP file for Drive...';

            try {
                const zip = new JSZip();
                const chronologicalCount = getAndIncrementParticipantExportCount(participantName);
                const folderName = `${participantName}_${chronologicalCount}_Drawings`;
                const folder = zip.folder(folderName);
                
                let filesAdded = 0;

                for (const freq of frequencies) {
                    const key = getFrequencyKey(freq);
                    if (allFrequencyData[key].length > 0) {
                        const dataURL = generateImageForFrequency(freq);
                        const filename = `${participantName}_${freq.hz}Hz_${freq.db}dB.png`;
                        const base64Data = dataURL.split(',')[1];
                        
                        folder.file(filename, base64Data, { base64: true });
                        filesAdded++;
                    }
                }

                if (filesAdded === 0) {
                    document.getElementById('status-message').textContent = 'Status: No drawings found to export.';
                    return;
                }

                // Generate ZIP as base64
                document.getElementById('status-message').textContent = 'Status: Uploading to Google Drive...';
                const zipBlob = await zip.generateAsync({ type: "base64" });
                const fileName = `${participantName}_${chronologicalCount}_Drawings.zip`;

                // Send to Google Apps Script
                await fetch(driveUrl, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileName: fileName,
                        fileData: zipBlob,
                        mimeType: 'application/zip'
                    })
                });

                document.getElementById('status-message').textContent = `Status: Successfully uploaded ${filesAdded} images to Google Drive!`;
                alert(`${filesAdded} drawings exported to Google Drive successfully! Check your Drive folder.`);

            } catch (error) {
                console.error('Drive export error:', error);
                document.getElementById('status-message').textContent = 'Status: Drive export failed';
                alert('Export to Google Drive failed. Please check your Web App URL and try again.');
            }
        }

        function resetAll() {
            document.getElementById('participant-name').value = '';
            
            frequencies.forEach(freq => {
                const key = getFrequencyKey(freq);
                allFrequencyData[key] = [];
                undoStacks[key] = [];
                redoStacks[key] = [];
            });
            
            selectedColor = colors[0];
            brushSize = 5;
            document.getElementById('brush-size-slider').value = 5;
            document.getElementById('brush-size-value').textContent = '5';
            
            document.querySelectorAll('.color-button').forEach((btn, index) => {
                btn.classList.remove('selected');
                if (index === 0) btn.classList.add('selected');
            });
            
            redrawCanvas();
            runAnalysis();
            
            document.getElementById('status-message').textContent = 'Status: All data has been reset (background image preserved)';
            
            const firstFreqTab = document.querySelector('.frequency-tab');
            if (firstFreqTab) {
                firstFreqTab.click();
            }
        }

        // Initialize canvas and event listeners
        function initializeCanvas() {
            canvas = document.getElementById('drawing-canvas');
            ctx = canvas.getContext('2d');
            
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;

            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);

            // Touch events
            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing);
            
            createFrequencyTabs();
            createColorPalette();
            redrawCanvas();
        }

        // Initialize on page load
        window.onload = function() {
            initializeCanvas();
            
            // Load saved URL if it exists
            const savedSheetsUrl = localStorage.getItem('sheetsUrl');
            if (savedSheetsUrl) {
                document.getElementById('sheets-url-input').value = savedSheetsUrl;
            }
            
            const savedDriveUrl = localStorage.getItem('driveUrl');
            if (savedDriveUrl) {
                document.getElementById('drive-url-input').value = savedDriveUrl;
            }
            
            // Register service worker for PWA functionality
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered:', registration);
                    })
                    .catch(error => {
                        console.log('Service Worker registration failed:', error);
                    });
            }
            
            // PWA install prompt handler
            let deferredPrompt;
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
            });
            
            // Event listeners for controls
            document.getElementById('brush-size-slider').addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                document.getElementById('brush-size-value').textContent = brushSize;
            });
            
            document.getElementById('clear-canvas').addEventListener('click', () => {
                const message = `Are you sure you want to clear the drawing for ${currentFrequency.hz} Hz?`;
                if (confirm(message)) {
                    saveState();
                    allFrequencyData[getFrequencyKey(currentFrequency)] = [];
                    redrawCanvas();
                    runAnalysis();
                    document.getElementById('status-message').textContent = 'Status: Canvas cleared for current frequency';
                }
            });
            
            document.getElementById('toggle-drawing').addEventListener('click', () => {
                isDrawing = !isDrawing;
                const button = document.getElementById('toggle-drawing');
                if (isDrawing) {
                    button.textContent = 'Stop Drawing';
                    button.className = 'w-full sm:w-auto px-6 py-2.5 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-green-500 to-green-600 text-white hover:from-green-600 hover:to-green-700 shadow-lg hover:shadow-xl';
                    canvas.style.cursor = 'crosshair';
                    document.getElementById('status-message').textContent = 'Status: Drawing Enabled';
                } else {
                    button.textContent = 'Start Drawing';
                    button.className = 'w-full sm:w-auto px-6 py-2.5 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-red-500 to-red-600 text-white hover:from-red-600 hover:to-red-700 shadow-lg hover:shadow-xl';
                    canvas.style.cursor = 'default';
                    document.getElementById('status-message').textContent = 'Status: Drawing Disabled';
                }
            });
            
            document.getElementById('undo-button').addEventListener('click', undo);
            document.getElementById('redo-button').addEventListener('click', redo);
            document.getElementById('image-upload').addEventListener('change', handleImageUpload);
            
            // EVENT LISTENER: Download all drawings as ZIP with chronological count
            document.getElementById('download-all-zip').addEventListener('click', downloadAllImagesAsZip);
            
            document.getElementById('export-csv').addEventListener('click', exportCSV);
            document.getElementById('export-drive-btn').addEventListener('click', exportToGoogleDrive);
            document.getElementById('export-sheets-btn').addEventListener('click', exportToGoogleSheets);
            
            document.getElementById('reset-all').addEventListener('click', () => {
                const confirmMessage = `‚ö†Ô∏è WARNING: This will reset EVERYTHING including:
‚Ä¢ Participant name
‚Ä¢ All drawings for all frequencies
‚Ä¢ All undo/redo history
‚Ä¢ Selected colors and brush settings

The background image will be kept.

Are you sure you want to reset everything?`;
                
                if (confirm(confirmMessage)) {
                    resetAll();
                }
            });
            
            document.getElementById('clear-sheets-url').addEventListener('click', (e) => {
                e.preventDefault();
                localStorage.removeItem('sheetsUrl');
                document.getElementById('sheets-url-input').value = '';
                document.getElementById('status-message').textContent = 'Status: Saved Sheets URL cleared';
            });
            
            document.getElementById('clear-drive-url').addEventListener('click', (e) => {
                e.preventDefault();
                localStorage.removeItem('driveUrl');
                document.getElementById('drive-url-input').value = '';
                document.getElementById('status-message').textContent = 'Status: Saved Drive URL cleared';
            });
        };
    </script>
</body>
</html>
